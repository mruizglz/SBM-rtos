%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}

\PassOptionsToPackage{booktabs}{sphinx}
\PassOptionsToPackage{colorrows}{sphinx}

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{tgtermes}
\usepackage{tgheros}
\renewcommand{\ttdefault}{txtt}



\usepackage[Bjarne]{fncychap}
\usepackage[,numfigreset=1,mathnumfig,mathnumsep={.}]{sphinx}

\fvset{fontsize=auto}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}


\usepackage{sphinxmessages}
\setcounter{tocdepth}{3}
\setcounter{secnumdepth}{3}


\title{CMSIS\sphinxhyphen{}RTOS V2 Ejemplos}
\date{Oct 24, 2025}
\release{1.0}
\author{Mariano Ruiz}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\ifdefined\shorthandoff
  \ifnum\catcode`\=\string=\active\shorthandoff{=}\fi
  \ifnum\catcode`\"=\active\shorthandoff{"}\fi
\fi

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}
\sphinxstepscope



\sphinxAtStartPar
El repositorio contiene ejemplos básicos para entender el funcionamiento de la API CMSIS\sphinxhyphen{}RTOS V2 utilizando el sistema operativo RTX version 5. Los ejemplos están implementados para el STM32F429 y utilizan mínimamente los periféricos del microcontrolador y hacer hincapié en los conceptos de manejo del Sistema Operativo.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Uso de los ejemplos

\sphinxAtStartPar
Los ejemplos se han implementado para la asignatura \sphinxstylestrong{Sistemas Basados en Microprocesador} de la \sphinxstylestrong{(ETSI Sistemas de Telecomunicación) Universidad Politécnica de Madrid} y se pueden ejecutar utilizando el simulador del microprocesador incluido en el entorno de ARM keil Microvision o bien el hardware.
\end{sphinxadmonition}


\chapter{Documentación en otros idiomas}
\label{\detokenize{cmsis-rtos:documentacion-en-otros-idiomas}}
\sphinxAtStartPar
\sphinxhref{https://translate.google.com/translate?hl=en\&sl=es\&u=https://mruizglz.github.io/SBM-rtos}{Traducción a inglés \sphinxhyphen{} English translation}


\chapter{Descarga del código}
\label{\detokenize{cmsis-rtos:descarga-del-codigo}}
\sphinxAtStartPar
Para descargar el código puede utilizar un cliente de git en su ordenador o bien descargar el repositorio completo (formato \sphinxstylestrong{zip}). Las instrucciones para clonar el repositorio son:

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Descarga del código

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{}\PYG{+w}{ }git\PYG{+w}{ }clone\PYG{+w}{ }https://github.com/mruizglz/SBM\PYGZhy{}rtos.git
\end{sphinxVerbatim}
\end{sphinxadmonition}


\chapter{Listado de ejemplos incluidos}
\label{\detokenize{cmsis-rtos:listado-de-ejemplos-incluidos}}

\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Ejemplos incluidos}\label{\detokenize{cmsis-rtos:id1}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{TT}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
Carpeta
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Objetivos
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
\sphinxstylestrong{ejemplothreads}
&
\sphinxAtStartPar
Aprender el manejo básico de creación de threads. Uso de la misma función con parámetros parea crear multiples threads
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{ejemplothreads\sphinxhyphen{}flags}
&
\sphinxAtStartPar
Sincronización de threads usando flags
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{ejemplothreads\sphinxhyphen{}queues}
&
\sphinxAtStartPar
Intercambio de datos entre threads usando colas
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{ejemplothreads\sphinxhyphen{}timers}
&
\sphinxAtStartPar
Gestion de timers “software”
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\chapter{Configuración del Proyecto de Keil}
\label{\detokenize{cmsis-rtos:configuracion-del-proyecto-de-keil}}

\section{Uso del simulador}
\label{\detokenize{cmsis-rtos:uso-del-simulador}}
\sphinxAtStartPar
ARM Keil Microvision dispone de opciones para configurar donde se ejecutará la aplicación (Icono \sphinxstyleemphasis{Options for Target}). Seleccione \sphinxstylestrong{Debug} y active el uso del simulador (\sphinxstylestrong{Use Simulator}).
Es necesario que configure el fichero de inicialización (\sphinxstylestrong{Initialization File}) para que cargue un script de configuración del microcontrolador. En este caso, seleccione el fichero \sphinxcode{\sphinxupquote{simulator.ini}} que se encuentra en cada una de las carpetas de ejmplo. Por ejemplo en la carpeta \sphinxcode{\sphinxupquote{.\textbackslash{}ejemplothreads}} del repositorio encontrará el fichero \sphinxstylestrong{simulador.ini} con este contenido:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+na}{MAP 0x40000000,0x400FFFFF read write}
\PYG{n+na}{MAP 0xE0000000,0xE00FFFFF read write}
\end{sphinxVerbatim}

\sphinxAtStartPar
El significado de estas instrucciones es habilitar para el simulador las operaciones de lectura/escritura en las zonas de memoria donde se encuentran los periféricos.

\begin{sphinxadmonition}{tip}{Tip:}
\sphinxAtStartPar
Cuando se usa el simulador de Keil las operaciones de escritura y lectura de los periféricos no tienen ningún efecto y por tanto no podrá simular el comportamiento hardware de los mismos
Todas las operaciones de la capa HAL que actúan sobre periféricos no tendrán ningún efecto. Por ejemplo, si en el código se configura un pin como salida y luego se escribe un valor alto en el mismo, no podrá ver ningún cambio en el estado del pin.
\end{sphinxadmonition}

\sphinxAtStartPar
Como podrá ver en el código del programa \sphinxcode{\sphinxupquote{main.c}} existe compilación condicional para incluir o no el código de configuración del RCC para usar un reloj externo (HSE).
Si utiliza el simulador debe desactivar esta opción y usar el reloj interno (HSI) que es el que utiliza el simulador. La pestaña \sphinxstylestrong{C/C++(AC6)} permite añadir en \sphinxcode{\sphinxupquote{define}} etiquetas. Incluya \sphinxcode{\sphinxupquote{SIMULATOR}} si quiere utilizar el simulator.


\section{Uso del hardware}
\label{\detokenize{cmsis-rtos:uso-del-hardware}}
\sphinxAtStartPar
Si dispone de una placa con el microcontrolador STM32F429 puede ejecutar el código directamente en el hardware. En este caso debe configurar las opciones del proyecto para que utilice el ST\sphinxhyphen{}Link en lugar del simulador.

\sphinxAtStartPar
\sphinxstylestrong{No defina la variable} \sphinxcode{\sphinxupquote{SIMULATOR}} en las opciones de compilación para que el circuito de RCC se configure adecuadamente.


\section{Depuración de aplicaciones usando CMSIS\sphinxhyphen{}RTOS V2}
\label{\detokenize{cmsis-rtos:depuracion-de-aplicaciones-usando-cmsis-rtos-v2}}
\sphinxAtStartPar
La depuración de las aplicaciones se debe realizar combinando el uso de puntos de ruptura y de la aplicación \sphinxcode{\sphinxupquote{RTX RTOS view}} disponible en el menu \sphinxcode{\sphinxupquote{View\sphinxhyphen{}\textgreater{}Watch Windows\sphinxhyphen{}\textgreater{}RTX RTOS}}.
Esta permite ver el estado en el que se encuentran los diferentes objetos del sistema operativo cuando el procesador pausa su ejecución. Herramientas complementarias para entender
el funcionamiento de una aplicación son: \sphinxcode{\sphinxupquote{Logyc Analyzer}}, \sphinxcode{\sphinxupquote{Performance Analyzer}}, \sphinxcode{\sphinxupquote{System Analyzer}}, \sphinxcode{\sphinxupquote{Event Recorder}}. \sphinxcode{\sphinxupquote{Event Statistics}} y \sphinxcode{\sphinxupquote{Symbols Window}}


\section{Symbols Window}
\label{\detokenize{cmsis-rtos:symbols-window}}
\sphinxAtStartPar
La opción \sphinxstylestrong{Symbols Window} permite visualizar y explorar todos los símbolos definidos en el proyecto, incluyendo variables globales, variables estáticas, funciones y direcciones de registros . Esta ventana es útil para depuración y análisis en tiempo real.
\begin{itemize}
\item {} 
\sphinxAtStartPar
Muestra una lista jerárquica de todos los símbolos disponibles en el programa cargado.

\item {} 
\sphinxAtStartPar
Permite buscar y filtrar símbolos por nombre.

\item {} 
\sphinxAtStartPar
Muestra la dirección y el valor actual de cada símbolo durante la sesión de depuración.

\item {} 
\sphinxAtStartPar
Facilita el arrastre de variables a otras ventanas de análisis, como el Watch Window o el Logic Analyzer.

\item {} 
\sphinxAtStartPar
Permite examinar variables optimizadas si están disponibles en la tabla de símbolos.

\item {} 
\sphinxAtStartPar
Si un símbolo no aparece, verifique la configuración de optimización del compilador y el ámbito de la variable.

\end{itemize}

\sphinxAtStartPar
Para utilizarlo:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Iniciar una sesión de depuración.

\item {} 
\sphinxAtStartPar
Abrir la ventana desde el menú: \sphinxmenuselection{View \(\rightarrow\) Symbol Window}.

\item {} 
\sphinxAtStartPar
Buscar el símbolo deseado utilizando el campo de filtro.

\item {} 
\sphinxAtStartPar
Arrastrar el símbolo a la ventana de Watch o \sphinxcode{\sphinxupquote{Logic Analyzer}} para su monitorización.

\end{enumerate}


\section{Logic Analyzer}
\label{\detokenize{cmsis-rtos:logic-analyzer}}
\sphinxAtStartPar
Permite visualizar la evolución temporal de variables que sean globales a la aplicación, el contenido de posiciones de memoria, etc. Se puede configurar el rango de valores y es muy apropiado para comparar visualmente la evolución de la aplicación software a través del seguimiento de variables.
Para agregar señales al \sphinxcode{\sphinxupquote{Logic Analyzer}} puede arrastrarlas de la ventana de símbolos o escribir el nombre de la misma.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[scale=0.5]{{logicanalyzer}.png}
\caption{Analizador lógico de ARM Keil Microvision.}\label{\detokenize{cmsis-rtos:id2}}\end{figure}


\section{Performance Analyzer}
\label{\detokenize{cmsis-rtos:performance-analyzer}}
\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
Solo esta disponible en Simulación porque el ST\sphinxhyphen{}LINK no lo soporta
\end{sphinxadmonition}

\sphinxAtStartPar
Permite conocer el porcentaje de tiempo utilizado por cada porción del código de nuestra aplicación.
Para utilizarlo:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Iniciar una sesión de depuración.

\item {} 
\sphinxAtStartPar
Abrir la ventana desde el menú: \sphinxmenuselection{View \(\rightarrow\) Analysis Windows \(\rightarrow\) Performance analyzer}.

\item {} 
\sphinxAtStartPar
Se muestra una lista de las diferentes secciones de código.

\end{enumerate}

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[scale=0.5]{{performanceanalyzer}.png}
\end{figure}


\chapter{Código en main.c de los ejemplos}
\label{\detokenize{cmsis-rtos:codigo-en-main-c-de-los-ejemplos}}
\sphinxAtStartPar
El código del programa principal está detallado a continuación y es el mismo o muy similar para todos los ejemplos:
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZdq{}main.h\PYGZdq{}}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef \PYGZus{}RTE\PYGZus{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZdq{}RTE\PYGZus{}Components.h\PYGZdq{}}\PYG{c+c1}{             // Component selection}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef RTE\PYGZus{}CMSIS\PYGZus{}RTOS2                  }\PYG{c+c1}{// when RTE component CMSIS RTOS2 is used}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZdq{}cmsis\PYGZus{}os2.h\PYGZdq{}}\PYG{c+c1}{                  // ::CMSIS:RTOS2}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef RTE\PYGZus{}CMSIS\PYGZus{}RTOS2\PYGZus{}RTX5}
\PYG{c+cm}{/**}
\PYG{c+cm}{  * Override default HAL\PYGZus{}GetTick function}
\PYG{c+cm}{  */}
\PYG{k+kt}{uint32\PYGZus{}t}\PYG{+w}{ }\PYG{n+nf}{HAL\PYGZus{}GetTick}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{  }\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{uint32\PYGZus{}t}\PYG{+w}{ }\PYG{n}{ticks}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0U}\PYG{p}{;}
\PYG{+w}{        }\PYG{k+kt}{uint32\PYGZus{}t}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{;}

\PYG{+w}{  }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{osKernelGetState}\PYG{+w}{ }\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{osKernelRunning}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{uint32\PYGZus{}t}\PYG{p}{)}\PYG{n}{osKernelGetTickCount}\PYG{+w}{ }\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{  }\PYG{p}{\PYGZcb{}}

\PYG{+w}{  }\PYG{c+cm}{/* If Kernel is not running wait approximately 1 ms then increment}
\PYG{c+cm}{    and return auxiliary tick counter value */}
\PYG{+w}{  }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{SystemCoreClock}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{l+m+mi}{14U}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{l+m+mi}{0U}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{\PYGZus{}\PYGZus{}NOP}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{\PYGZus{}\PYGZus{}NOP}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{\PYGZus{}\PYGZus{}NOP}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{\PYGZus{}\PYGZus{}NOP}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{\PYGZus{}\PYGZus{}NOP}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{\PYGZus{}\PYGZus{}NOP}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{\PYGZus{}\PYGZus{}NOP}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{\PYGZus{}\PYGZus{}NOP}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{\PYGZus{}\PYGZus{}NOP}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{\PYGZus{}\PYGZus{}NOP}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{\PYGZus{}\PYGZus{}NOP}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{\PYGZus{}\PYGZus{}NOP}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{  }\PYG{p}{\PYGZcb{}}
\PYG{+w}{  }\PYG{k}{return}\PYG{+w}{ }\PYG{o}{+}\PYG{o}{+}\PYG{n}{ticks}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+cm}{/**}
\PYG{c+cm}{  * Override default HAL\PYGZus{}InitTick function}
\PYG{c+cm}{  */}
\PYG{n}{HAL\PYGZus{}StatusTypeDef}\PYG{+w}{ }\PYG{n+nf}{HAL\PYGZus{}InitTick}\PYG{p}{(}\PYG{k+kt}{uint32\PYGZus{}t}\PYG{+w}{ }\PYG{n}{TickPriority}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}

\PYG{+w}{  }\PYG{n}{UNUSED}\PYG{p}{(}\PYG{n}{TickPriority}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{  }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{HAL\PYGZus{}OK}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZdq{}Timer.h\PYGZdq{}}
\PYG{c+cm}{/** @addtogroup STM32F4xx\PYGZus{}HAL\PYGZus{}Examples}
\PYG{c+cm}{  * @\PYGZob{}}
\PYG{c+cm}{  */}

\PYG{c+cm}{/** @addtogroup Templates}
\PYG{c+cm}{  * @\PYGZob{}}
\PYG{c+cm}{  */}

\PYG{c+cm}{/* Private typedef \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}*/}
\PYG{c+cm}{/* Private define \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}*/}
\PYG{c+cm}{/* Private macro \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}*/}
\PYG{c+cm}{/* Private variables \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}*/}
\PYG{c+cm}{/* Private function prototypes \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}*/}
\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{SystemClock\PYGZus{}Config}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{Error\PYGZus{}Handler}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}\PYG{p}{;}

\PYG{c+cm}{/* Private functions \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}*/}
\PYG{c+cm}{/**}
\PYG{c+cm}{  * @brief  Main program}
\PYG{c+cm}{  * @param  None}
\PYG{c+cm}{  * @retval None}
\PYG{c+cm}{  */}

\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}
\PYG{p}{\PYGZob{}}

\PYG{+w}{  }\PYG{c+cm}{/* STM32F4xx HAL library initialization:}
\PYG{c+cm}{      \PYGZhy{} Configure the Flash prefetch, Flash preread and Buffer caches}
\PYG{c+cm}{      \PYGZhy{} Systick timer is configured by default as source of time base, but user}
\PYG{c+cm}{            can eventually implement his proper time base source (a general purpose}
\PYG{c+cm}{            timer for example or other time source), keeping in mind that Time base}
\PYG{c+cm}{            duration should be kept 1ms since PPP\PYGZus{}TIMEOUT\PYGZus{}VALUEs are defined and}
\PYG{c+cm}{            handled in milliseconds basis.}
\PYG{c+cm}{      \PYGZhy{} Low Level Initialization}
\PYG{c+cm}{    */}
\PYG{+w}{  }\PYG{n}{HAL\PYGZus{}Init}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{  }\PYG{c+cm}{/* Configure the system clock to 168 MHz */}
\PYG{+w}{  }\PYG{n}{SystemClock\PYGZus{}Config}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{  }\PYG{n}{SystemCoreClockUpdate}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{  }\PYG{c+cm}{/* Add your application code here}
\PYG{c+cm}{    */}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef RTE\PYGZus{}CMSIS\PYGZus{}RTOS2}
\PYG{+w}{  }\PYG{c+cm}{/* Initialize CMSIS\PYGZhy{}RTOS2 */}
\PYG{+w}{  }\PYG{n}{osKernelInitialize}\PYG{+w}{ }\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{  }\PYG{c+cm}{/* Create thread functions that start executing,}
\PYG{c+cm}{  Example: osThreadNew(app\PYGZus{}main, NULL, NULL); */}
\PYG{+w}{  }\PYG{n}{Init\PYGZus{}Threads}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{  }\PYG{c+cm}{/* Start thread execution */}
\PYG{+w}{  }\PYG{n}{osKernelStart}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}

\PYG{+w}{  }\PYG{c+cm}{/* Infinite loop */}
\PYG{+w}{  }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{+w}{  }\PYG{p}{\PYGZob{}}
\PYG{+w}{  }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{c+cm}{/**}
\PYG{c+cm}{  * @brief  System Clock Configuration}
\PYG{c+cm}{  *         The system Clock is configured as follow :}
\PYG{c+cm}{  *            System Clock source            = PLL (HSE)}
\PYG{c+cm}{  *            SYSCLK(Hz)                     = 168000000}
\PYG{c+cm}{  *            HCLK(Hz)                       = 168000000}
\PYG{c+cm}{  *            AHB Prescaler                  = 1}
\PYG{c+cm}{  *            APB1 Prescaler                 = 4}
\PYG{c+cm}{  *            APB2 Prescaler                 = 2}
\PYG{c+cm}{  *            HSE Frequency(Hz)              = 8000000}
\PYG{c+cm}{  *            PLL\PYGZus{}M                          = 25}
\PYG{c+cm}{  *            PLL\PYGZus{}N                          = 336}
\PYG{c+cm}{  *            PLL\PYGZus{}P                          = 2}
\PYG{c+cm}{  *            PLL\PYGZus{}Q                          = 7}
\PYG{c+cm}{  *            VDD(V)                         = 3.3}
\PYG{c+cm}{  *            Main regulator output voltage  = Scale1 mode}
\PYG{c+cm}{  *            Flash Latency(WS)              = 5}
\PYG{c+cm}{  * @param  None}
\PYG{c+cm}{  * @retval None}
\PYG{c+cm}{  */}
\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{SystemClock\PYGZus{}Config}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{  }\PYG{n}{RCC\PYGZus{}ClkInitTypeDef}\PYG{+w}{ }\PYG{n}{RCC\PYGZus{}ClkInitStruct}\PYG{p}{;}
\PYG{+w}{  }\PYG{n}{RCC\PYGZus{}OscInitTypeDef}\PYG{+w}{ }\PYG{n}{RCC\PYGZus{}OscInitStruct}\PYG{p}{;}

\PYG{+w}{  }\PYG{c+cm}{/* Enable Power Control clock */}
\PYG{+w}{  }\PYG{n}{\PYGZus{}\PYGZus{}HAL\PYGZus{}RCC\PYGZus{}PWR\PYGZus{}CLK\PYGZus{}ENABLE}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{  }\PYG{c+cm}{/* The voltage scaling allows optimizing the power consumption when the device is}
\PYG{c+cm}{    clocked below the maximum system frequency, to update the voltage scaling value}
\PYG{c+cm}{    regarding system frequency refer to product datasheet.  */}
\PYG{+w}{  }\PYG{n}{\PYGZus{}\PYGZus{}HAL\PYGZus{}PWR\PYGZus{}VOLTAGESCALING\PYGZus{}CONFIG}\PYG{p}{(}\PYG{n}{PWR\PYGZus{}REGULATOR\PYGZus{}VOLTAGE\PYGZus{}SCALE1}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{  }\PYG{c+cm}{/* Enable HSE Oscillator and activate PLL with HSE as source */}
\PYG{+w}{  }\PYG{n}{RCC\PYGZus{}OscInitStruct}\PYG{p}{.}\PYG{n}{OscillatorType}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{RCC\PYGZus{}OSCILLATORTYPE\PYGZus{}HSE}\PYG{p}{;}
\PYG{+w}{  }\PYG{n}{RCC\PYGZus{}OscInitStruct}\PYG{p}{.}\PYG{n}{HSEState}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{RCC\PYGZus{}HSE\PYGZus{}ON}\PYG{p}{;}
\PYG{+w}{  }\PYG{n}{RCC\PYGZus{}OscInitStruct}\PYG{p}{.}\PYG{n}{PLL}\PYG{p}{.}\PYG{n}{PLLState}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{RCC\PYGZus{}PLL\PYGZus{}ON}\PYG{p}{;}
\PYG{+w}{  }\PYG{n}{RCC\PYGZus{}OscInitStruct}\PYG{p}{.}\PYG{n}{PLL}\PYG{p}{.}\PYG{n}{PLLSource}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{RCC\PYGZus{}PLLSOURCE\PYGZus{}HSE}\PYG{p}{;}
\PYG{+w}{  }\PYG{n}{RCC\PYGZus{}OscInitStruct}\PYG{p}{.}\PYG{n}{PLL}\PYG{p}{.}\PYG{n}{PLLM}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{4}\PYG{p}{;}
\PYG{+w}{  }\PYG{n}{RCC\PYGZus{}OscInitStruct}\PYG{p}{.}\PYG{n}{PLL}\PYG{p}{.}\PYG{n}{PLLN}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{168}\PYG{p}{;}
\PYG{+w}{  }\PYG{n}{RCC\PYGZus{}OscInitStruct}\PYG{p}{.}\PYG{n}{PLL}\PYG{p}{.}\PYG{n}{PLLP}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{RCC\PYGZus{}PLLP\PYGZus{}DIV2}\PYG{p}{;}
\PYG{+w}{  }\PYG{n}{RCC\PYGZus{}OscInitStruct}\PYG{p}{.}\PYG{n}{PLL}\PYG{p}{.}\PYG{n}{PLLQ}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{7}\PYG{p}{;}
\PYG{+w}{  }\PYG{k}{if}\PYG{p}{(}\PYG{n}{HAL\PYGZus{}RCC\PYGZus{}OscConfig}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{RCC\PYGZus{}OscInitStruct}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{!}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{HAL\PYGZus{}OK}\PYG{p}{)}
\PYG{+w}{  }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{c+cm}{/* Initialization Error */}
\PYG{+w}{    }\PYG{n}{Error\PYGZus{}Handler}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{  }\PYG{p}{\PYGZcb{}}

\PYG{+w}{  }\PYG{c+cm}{/* Select PLL as system clock source and configure the HCLK, PCLK1 and PCLK2}
\PYG{c+cm}{    clocks dividers */}
\PYG{+w}{  }\PYG{n}{RCC\PYGZus{}ClkInitStruct}\PYG{p}{.}\PYG{n}{ClockType}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{RCC\PYGZus{}CLOCKTYPE\PYGZus{}SYSCLK}\PYG{+w}{ }\PYG{o}{|}\PYG{+w}{ }\PYG{n}{RCC\PYGZus{}CLOCKTYPE\PYGZus{}HCLK}\PYG{+w}{ }\PYG{o}{|}\PYG{+w}{ }\PYG{n}{RCC\PYGZus{}CLOCKTYPE\PYGZus{}PCLK1}\PYG{+w}{ }\PYG{o}{|}\PYG{+w}{ }\PYG{n}{RCC\PYGZus{}CLOCKTYPE\PYGZus{}PCLK2}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{  }\PYG{n}{RCC\PYGZus{}ClkInitStruct}\PYG{p}{.}\PYG{n}{SYSCLKSource}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{RCC\PYGZus{}SYSCLKSOURCE\PYGZus{}PLLCLK}\PYG{p}{;}
\PYG{+w}{  }\PYG{n}{RCC\PYGZus{}ClkInitStruct}\PYG{p}{.}\PYG{n}{AHBCLKDivider}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{RCC\PYGZus{}SYSCLK\PYGZus{}DIV1}\PYG{p}{;}
\PYG{+w}{  }\PYG{n}{RCC\PYGZus{}ClkInitStruct}\PYG{p}{.}\PYG{n}{APB1CLKDivider}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{RCC\PYGZus{}HCLK\PYGZus{}DIV4}\PYG{p}{;}
\PYG{+w}{  }\PYG{n}{RCC\PYGZus{}ClkInitStruct}\PYG{p}{.}\PYG{n}{APB2CLKDivider}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{RCC\PYGZus{}HCLK\PYGZus{}DIV2}\PYG{p}{;}
\PYG{+w}{  }\PYG{k}{if}\PYG{p}{(}\PYG{n}{HAL\PYGZus{}RCC\PYGZus{}ClockConfig}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{RCC\PYGZus{}ClkInitStruct}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{FLASH\PYGZus{}LATENCY\PYGZus{}5}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{!}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{HAL\PYGZus{}OK}\PYG{p}{)}
\PYG{+w}{  }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{c+cm}{/* Initialization Error */}
\PYG{+w}{    }\PYG{n}{Error\PYGZus{}Handler}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{  }\PYG{p}{\PYGZcb{}}

\PYG{+w}{  }\PYG{c+cm}{/* STM32F405x/407x/415x/417x Revision Z devices: prefetch is supported */}
\PYG{+w}{  }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{HAL\PYGZus{}GetREVID}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mh}{0x1001}\PYG{p}{)}
\PYG{+w}{  }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{c+cm}{/* Enable the Flash prefetch */}
\PYG{+w}{    }\PYG{n}{\PYGZus{}\PYGZus{}HAL\PYGZus{}FLASH\PYGZus{}PREFETCH\PYGZus{}BUFFER\PYGZus{}ENABLE}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{  }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{c+cm}{/**}
\PYG{c+cm}{  * @brief  This function is executed in case of error occurrence.}
\PYG{c+cm}{  * @param  None}
\PYG{c+cm}{  * @retval None}
\PYG{c+cm}{  */}
\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{Error\PYGZus{}Handler}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{  }\PYG{c+cm}{/* User may add here some code to deal with this error */}
\PYG{+w}{  }\PYG{k}{while}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{+w}{  }\PYG{p}{\PYGZob{}}
\PYG{+w}{  }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\end{quote}


\section{Algunos detalles importantes}
\label{\detokenize{cmsis-rtos:algunos-detalles-importantes}}\begin{quote}

\sphinxAtStartPar
1. Al utilizar el sistema operativo CMSIS\sphinxhyphen{}RTOS V2 se ha definido RTE\_CMSIS\_RTOS2\_RTX5. Esto supone incluir dos funciones que anulan las definidas anteriormente.
Estas funciones son \sphinxcode{\sphinxupquote{HAL\_GetTick}}   y \sphinxcode{\sphinxupquote{HAL\_InitTick}}. La primera tiene dos comportamientos diferentes. Si el sistema operativo esta en ejecución devuelve el valor retornado por \sphinxcode{\sphinxupquote{osKernelGetTickCount}} que indica el número de ticks que han pasado desde que se arranco el SO.     * Si \sphinxstylestrong{no} se ha arrancado el SO la función produce un retardo de aproximadamente 1ms e incrementa la variable estática \sphinxstyleemphasis{ticks}.
\sphinxcode{\sphinxupquote{Hal\_GetTick}} se utiliza por las librerías HAL de STM para controlar timeouts en la gestión de los periféricos. La segunda función, \sphinxcode{\sphinxupquote{HAL\_InitTick}}, es usada por la capa HAL para programar un timer HW que proporcione una interrupción cada 1ms. Por defecto este timer es el SysTick timer.
Cuando no se usa el sistema operativo esta función realiza las operaciones del código descrito en \sphinxstyleemphasis{stm32f4xx\_hal.c} Al usar el SO esta función se substituye por la definida en el \sphinxcode{\sphinxupquote{main.c}}, que no realiza ninguna operación.
Es el código del sistema operativo quien se encarga de inicializar el SysTick (os\_systick.c).
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
\sphinxAtStartPar
Despues del código de inicialización de la libraría HAL y de la configuración del RCC del micro (que por cierto utiliza la función HAL\_GetTick) se procede a ejecutar la siguiente porción de código:

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef RTE\PYGZus{}CMSIS\PYGZus{}RTOS2}
\PYG{+w}{  }\PYG{c+cm}{/* Initialize CMSIS\PYGZhy{}RTOS2 */}
\PYG{+w}{  }\PYG{n}{osKernelInitialize}\PYG{+w}{ }\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{  }\PYG{c+cm}{/* Create thread functions that start executing,}
\PYG{c+cm}{  Example: osThreadNew(app\PYGZus{}main, NULL, NULL); */}
\PYG{+w}{  }\PYG{n}{Init\PYGZus{}Threads}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{  }\PYG{c+cm}{/* Start thread execution */}
\PYG{+w}{  }\PYG{n}{osKernelStart}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}

\PYG{+w}{  }\PYG{c+cm}{/* Infinite loop */}
\PYG{+w}{  }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{+w}{  }\PYG{p}{\PYGZob{}}
\PYG{+w}{  }\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
La función \sphinxcode{\sphinxupquote{osKernelInitialize}} inicializa el Sistema Operativo. La función \sphinxcode{\sphinxupquote{init\_Threads}} contiene el código de creación de los recursos necesarios en este ejemplo, y \sphinxcode{\sphinxupquote{osKernelStart}} comienza la ejecución de los diferentes objetos del SO sin retornar.
Eso quiere decir que la porción del código while es código muerto.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{2}
\item {} 
\sphinxAtStartPar
Toda la inicialización del hardware se debe hacer antes de lanzar la ejecución del SO.
Puede incluirse en el código específico de cada thread, en funciones que se ejecuten entre osKernelInitialize y osKernelStart, o en funciones que se incluyan antes de llamar a osKernelInitialize. En cualquier caso debe tener cuidado con el mecanismo de retardo que utiliza en cada parte de la aplicación.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
No se recomienda el uso de la función HAL\_Delay cuando se esta ejecutando el SO porque la función se puede quedar bloqueada.
\end{sphinxadmonition}

\end{enumerate}
\end{quote}

\sphinxstepscope


\chapter{Uso básico de un thread en CMSIS RTOS v2}
\label{\detokenize{ejemplothread:uso-basico-de-un-thread-en-cmsis-rtos-v2}}\label{\detokenize{ejemplothread:ejemplothread}}\label{\detokenize{ejemplothread::doc}}
\sphinxAtStartPar
Esta sección describe el funcionamiento de un programa (\sphinxstylestrong{ejemplothread}) en C que utiliza CMSIS RTOS v2 y la biblioteca HAL de STM32 para controlar un LED mediante un hilo.


\section{Descripción General de ejemplothread}
\label{\detokenize{ejemplothread:descripcion-general-de-ejemplothread}}
\sphinxAtStartPar
El programa crea un hilo que maneja un LED conectado al pin PB0  del microcontrolador STM32F4.El hilo alterna el estado del LED con una frecuencia configurable, utilizando funciones del sistema operativo en tiempo real (RTOS) y la biblioteca HAL para la configuración y manipulación de los pines GPIO.


\section{Estructura de Datos}
\label{\detokenize{ejemplothread:estructura-de-datos}}
\sphinxAtStartPar
Se define una estructura llamada \sphinxcode{\sphinxupquote{mygpio\_pin}} que encapsula toda la información necesaria para controlar un LED:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{GPIO\_InitTypeDef pin}}: configuración del pin (modo, velocidad, tipo de salida).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{GPIO\_TypeDef *port}}: puerto GPIO al que pertenece el pin.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{int delay}}: retardo en ms entre cada cambio de estado del LED.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{uint8\_t counter}}: contador que se alterna en cada iteración del hilo.

\end{itemize}

\sphinxAtStartPar
Esta estructura permite pasar todos los parámetros necesarios a la función del hilo de forma organizada.


\section{Inicialización de los hilos}
\label{\detokenize{ejemplothread:inicializacion-de-los-hilos}}
\sphinxAtStartPar
La función \sphinxcode{\sphinxupquote{Init\_Thread}} realiza las siguientes tareas:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Habilita el reloj del puerto GPIOB.

\item {} 
\sphinxAtStartPar
Configura \sphinxcode{\sphinxupquote{mygpio\_pin}} para el pin PB0.

\item {} 
\sphinxAtStartPar
Crea un hilo con \sphinxcode{\sphinxupquote{osThreadNew}}, que ejecuta la función \sphinxcode{\sphinxupquote{Thread}} pasándole una estructura \sphinxcode{\sphinxupquote{mygpio\_pin}} para el pin PB0.

\end{enumerate}


\section{Función del hilo}
\label{\detokenize{ejemplothread:funcion-del-hilo}}
\sphinxAtStartPar
La función \sphinxcode{\sphinxupquote{Thread}} realiza lo siguiente:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Inicializa el pin GPIO usando \sphinxcode{\sphinxupquote{HAL\_GPIO\_Init}}.

\item {} 
\sphinxAtStartPar
Entra en un bucle infinito donde:
\sphinxhyphen{} Alterna el valor del contador con \sphinxcode{\sphinxupquote{\textasciitilde{}counter}}.
\sphinxhyphen{} Cambia el estado del pin con \sphinxcode{\sphinxupquote{HAL\_GPIO\_TogglePin}}.
\sphinxhyphen{} Espera el tiempo definido en \sphinxcode{\sphinxupquote{delay}} usando \sphinxcode{\sphinxupquote{osDelay}}.

\end{enumerate}

\sphinxAtStartPar
Esto provoca que el LED conectado al pin correspondiente parpadee con una frecuencia que es configurable.


\section{Uso de HAL y CMSIS RTOS}
\label{\detokenize{ejemplothread:uso-de-hal-y-cmsis-rtos}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{HAL (Hardware Abstraction Layer)}: se utiliza para configurar e inicializar los pines GPIO de forma sencilla y portable.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{CMSIS RTOS v2}: proporciona las funciones para crear y gestionar hilos, como \sphinxcode{\sphinxupquote{osThreadNew}} y \sphinxcode{\sphinxupquote{osDelay}}.

\end{itemize}


\section{Código Fuente}
\label{\detokenize{ejemplothread:codigo-fuente}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZdq{}cmsis\PYGZus{}os2.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZdq{}stm32f4xx\PYGZus{}hal.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}stdlib.h\PYGZgt{}}

\PYG{n}{osThreadId\PYGZus{}t}\PYG{+w}{ }\PYG{n}{tid\PYGZus{}Thread}\PYG{p}{;}

\PYG{n}{GPIO\PYGZus{}InitTypeDef}\PYG{+w}{ }\PYG{n}{led\PYGZus{}ld1}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{p}{.}\PYG{n}{Pin}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{GPIO\PYGZus{}PIN\PYGZus{}0}\PYG{p}{,}
\PYG{+w}{    }\PYG{p}{.}\PYG{n}{Mode}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{GPIO\PYGZus{}MODE\PYGZus{}OUTPUT\PYGZus{}PP}\PYG{p}{,}
\PYG{+w}{    }\PYG{p}{.}\PYG{n}{Pull}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{GPIO\PYGZus{}NOPULL}\PYG{p}{,}
\PYG{+w}{    }\PYG{p}{.}\PYG{n}{Speed}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{GPIO\PYGZus{}SPEED\PYGZus{}FREQ\PYGZus{}LOW}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}



\PYG{k}{typedef}\PYG{+w}{ }\PYG{k}{struct}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{GPIO\PYGZus{}InitTypeDef}\PYG{+w}{ }\PYG{n}{pin}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{GPIO\PYGZus{}TypeDef}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{port}\PYG{p}{;}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{delay}\PYG{p}{;}
\PYG{+w}{    }\PYG{k+kt}{uint8\PYGZus{}t}\PYG{+w}{ }\PYG{n}{counter}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{+w}{ }\PYG{n}{mygpio\PYGZus{}pin}\PYG{p}{;}

\PYG{n}{mygpio\PYGZus{}pin}\PYG{+w}{ }\PYG{n}{pinB0}\PYG{p}{;}


\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{Init\PYGZus{}Thread}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{\PYGZus{}\PYGZus{}HAL\PYGZus{}RCC\PYGZus{}GPIOB\PYGZus{}CLK\PYGZus{}ENABLE}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{    }\PYG{n}{pinB0}\PYG{p}{.}\PYG{n}{pin}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{led\PYGZus{}ld1}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{pinB0}\PYG{p}{.}\PYG{n}{port}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{GPIOB}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{pinB0}\PYG{p}{.}\PYG{n}{delay}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{15}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{pinB0}\PYG{p}{.}\PYG{n}{counter}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{tid\PYGZus{}Thread}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{osThreadNew}\PYG{p}{(}\PYG{n}{Thread}\PYG{p}{,}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{void}\PYG{+w}{ }\PYG{o}{*}\PYG{p}{)}\PYG{o}{\PYGZam{}}\PYG{n}{pinB0}\PYG{p}{,}\PYG{+w}{ }\PYG{n+nb}{NULL}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{tid\PYGZus{}Thread}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{n+nb}{NULL}\PYG{p}{)}\PYG{+w}{ }\PYG{k}{return}\PYG{+w}{ }\PYG{l+m+mi}{\PYGZhy{}1}\PYG{p}{;}

\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{Thread}\PYG{p}{(}\PYG{k+kt}{void}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{argument}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{mygpio\PYGZus{}pin}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{gpio}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{mygpio\PYGZus{}pin}\PYG{+w}{ }\PYG{o}{*}\PYG{p}{)}\PYG{n}{argument}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{HAL\PYGZus{}GPIO\PYGZus{}Init}\PYG{p}{(}\PYG{n}{gpio}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{port}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{p}{(}\PYG{n}{gpio}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{pin}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{gpio}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{counter}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{HAL\PYGZus{}GPIO\PYGZus{}TogglePin}\PYG{p}{(}\PYG{n}{gpio}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{port}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{gpio}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{pin}\PYG{p}{.}\PYG{n}{Pin}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{osDelay}\PYG{p}{(}\PYG{n}{gpio}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{delay}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\section{Dependencias}
\label{\detokenize{ejemplothread:dependencias}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Librería HAL de STM32.

\item {} 
\sphinxAtStartPar
CMSIS RTOS v2.

\end{itemize}


\section{Preguntas y respuestas sobre ejemplothread}
\label{\detokenize{ejemplothread:preguntas-y-respuestas-sobre-ejemplothread}}
\sphinxAtStartPar
Esta sección contiene una serie de preguntas con sus respectivas respuestas sobre el funcionamiento del código que utiliza CMSIS RTOS v2 para controlar LEDs en una placa STM32.


\subsection{¿Qué hace este código?}
\label{\detokenize{ejemplothread:que-hace-este-codigo}}
\sphinxAtStartPar
Este código crea un hilo (thread) que controla un LED conectado al pin PB0 de una placa STM32F429. El hilo alterna el estado del LED (encendido/apagado) con una frecuencia determinada utilizando funciones del sistema operativo en tiempo real CMSIS RTOS v2.
Dentro del código del Thread se realiza un casting al tipo de estructura que se utiliza en el ejemplo


\subsection{¿Qué es la estructura \sphinxtitleref{mygpio\_pin}?}
\label{\detokenize{ejemplothread:que-es-la-estructura-mygpio-pin}}
\sphinxAtStartPar
Es una estructura de datos que encapsula la información necesaria para controlar un pin GPIO en este ejemplo:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pin}}: configuración del pin (tipo, velocidad, modo).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{port}}: puerto GPIO al que pertenece el pin (por ejemplo, GPIOB).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{delay}}: retardo en ms entre cada cambio de estado (toggle).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{counter}}: variable auxiliar que cuenta la cantidad de veces que se ha realizado el toggle.

\end{itemize}


\subsection{¿Cómo se inicializa el hilo?}
\label{\detokenize{ejemplothread:como-se-inicializa-el-hilo}}
\sphinxAtStartPar
La función \sphinxcode{\sphinxupquote{Init\_Thread()}} habilita el reloj del puerto GPIOB, rellena los parámetros de la estructura y crea un hilo con la función \sphinxcode{\sphinxupquote{osThreadNew()}}, pasando como argumento la estructura \sphinxcode{\sphinxupquote{mygpio\_pin}} correspondiente a cada LED.


\subsection{¿Qué hace la función \sphinxtitleref{Thread()}?}
\label{\detokenize{ejemplothread:que-hace-la-funcion-thread}}
\sphinxAtStartPar
La función \sphinxcode{\sphinxupquote{Thread(void *argument)}} se encarga de:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Inicializar el pin GPIO usando \sphinxcode{\sphinxupquote{HAL\_GPIO\_Init}}.

\item {} 
\sphinxAtStartPar
Ejecutar un bucle infinito donde:
\sphinxhyphen{} Se incrementa el valor de  \sphinxcode{\sphinxupquote{counter}}.
\sphinxhyphen{} Se cambia el estado del LED con \sphinxcode{\sphinxupquote{HAL\_GPIO\_TogglePin}}.
\sphinxhyphen{} Se espera el tiempo definido en \sphinxcode{\sphinxupquote{delay}} usando \sphinxcode{\sphinxupquote{osDelay}}.

\end{enumerate}


\subsection{¿Qué significa \sphinxtitleref{osDelay()}?}
\label{\detokenize{ejemplothread:que-significa-osdelay}}
\sphinxAtStartPar
Es una función del RTOS que suspende la ejecución del hilo actual durante un número determinado de ms.
Esto permite que otros hilos se ejecuten mientras tanto. \sphinxcode{\sphinxupquote{osDelay}} tiene como parámetro el número de ticks que la tarea estará bloqueada.
El número de ticks por segundo se define en el archivo \sphinxcode{\sphinxupquote{RTX\_Config.h}} (parámetro \sphinxcode{\sphinxupquote{Kernel Tick Frequency {[}Hz{]}}}). En este ejemplo se ha configurado a 1000, por lo que un tick equivale a 1 ms.


\subsection{¿Qué pasa si \sphinxtitleref{osThreadNew()} devuelve NULL?}
\label{\detokenize{ejemplothread:que-pasa-si-osthreadnew-devuelve-null}}
\sphinxAtStartPar
Significa que no se pudo crear el hilo. En ese caso, la función \sphinxcode{\sphinxupquote{Init\_Thread()}} devuelve \sphinxhyphen{}1 como señal de error. Si el programa principal que llama a esta función no comprueba el retorno no hay ningún control de errores.


\subsection{¿Qué ficheros de cabecera se utilizan?}
\label{\detokenize{ejemplothread:que-ficheros-de-cabecera-se-utilizan}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{cmsis\_os2.h}}: para funciones del sistema operativo en tiempo real.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{stm32f4xx\_hal.h}}: para funciones de acceso a hardware (HAL).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{stdlib.h}}: para funciones estándar de C que en este caso no se están incluyendo en el código.

\end{itemize}


\subsection{Determine la carga de la CPU en esta aplicación}
\label{\detokenize{ejemplothread:determine-la-carga-de-la-cpu-en-esta-aplicacion}}
\sphinxAtStartPar
Para determinar la carga que supone la ejecución del thread para la CPU se puede utilizar la utilidad de \sphinxcode{\sphinxupquote{Performance Analyzer}} en modo simulación.
La carga de CPU obtenida es insignificante. Si se cambia en la estructura de datos el campo \sphinxcode{\sphinxupquote{delay}} por 0 la carga del Thread pasa a ser del 19\%.

\sphinxstepscope


\chapter{Uso básico de threads en CMSIS RTOS v2}
\label{\detokenize{ejemplothreads:uso-basico-de-threads-en-cmsis-rtos-v2}}\label{\detokenize{ejemplothreads:ejemplothreads}}\label{\detokenize{ejemplothreads::doc}}
\sphinxAtStartPar
Esta sección describe el funcionamiento de un programa en C que utiliza CMSIS RTOS v2 y la biblioteca HAL de STM32 para controlar dos LEDs mediante hilos concurrentes.


\section{Descripción General}
\label{\detokenize{ejemplothreads:descripcion-general}}
\sphinxAtStartPar
El programa crea dos hilos que controlan dos LEDs conectados a los pines PB0 y PB7 del microcontrolador STM32F429. Cada hilo alterna el estado de su LED con una frecuencia distinta, utilizando funciones del sistema operativo en tiempo real (RTOS) y la biblioteca HAL para la configuración y manipulación de los pines GPIO.


\section{Estructura mygpio\_pin}
\label{\detokenize{ejemplothreads:estructura-mygpio-pin}}
\sphinxAtStartPar
Se define una estructura llamada \sphinxcode{\sphinxupquote{mygpio\_pin}} que encapsula toda la información necesaria para controlar un LED:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{GPIO\_InitTypeDef pin}}: configuración del pin (modo, velocidad, tipo de salida).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{GPIO\_TypeDef *port}}: puerto GPIO al que pertenece el pin.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{int delay}}: retardo en ms entre cada cambio de estado del LED.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{uint8\_t counter}}: contador que se incrementa en cada iteración del hilo.

\end{itemize}

\sphinxAtStartPar
Esta estructura permite pasar todos los parámetros necesarios a la función del hilo de forma organizada.


\section{Inicialización de los threads}
\label{\detokenize{ejemplothreads:inicializacion-de-los-threads}}
\sphinxAtStartPar
La función \sphinxcode{\sphinxupquote{Init\_Thread}} realiza las siguientes tareas:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Habilita el reloj del puerto GPIOB.

\item {} 
\sphinxAtStartPar
Configura dos instancias de \sphinxcode{\sphinxupquote{mygpio\_pin}} para los pines PB0 y PB7.

\item {} 
\sphinxAtStartPar
Crea dos hilos con \sphinxcode{\sphinxupquote{osThreadNew}}, cada uno ejecutando la función \sphinxcode{\sphinxupquote{Thread}} con una instancia diferente de \sphinxcode{\sphinxupquote{mygpio\_pin}}.

\end{enumerate}

\sphinxAtStartPar
Cada hilo se ejecuta de forma independiente y controla su propio LED.


\section{\sphinxstyleliteralintitle{\sphinxupquote{Thread()}}}
\label{\detokenize{ejemplothreads:thread}}
\sphinxAtStartPar
La función \sphinxcode{\sphinxupquote{Thread}} realiza lo siguiente:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Inicializa el pin GPIO usando \sphinxcode{\sphinxupquote{HAL\_GPIO\_Init}}.

\item {} 
\sphinxAtStartPar
Entra en un bucle infinito donde:
\sphinxhyphen{} Alterna el valor del contador con \sphinxcode{\sphinxupquote{\textasciitilde{}counter}}.
\sphinxhyphen{} Cambia el estado del pin con \sphinxcode{\sphinxupquote{HAL\_GPIO\_TogglePin}}.
\sphinxhyphen{} Espera el tiempo definido en \sphinxcode{\sphinxupquote{delay}} usando \sphinxcode{\sphinxupquote{osDelay}}.

\end{enumerate}

\sphinxAtStartPar
Esto provoca que el LED conectado al pin correspondiente parpadee con una frecuencia determinada.


\section{HAL y CMSIS RTOS}
\label{\detokenize{ejemplothreads:hal-y-cmsis-rtos}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{HAL (Hardware Abstraction Layer)}: se utiliza para configurar e inicializar los pines GPIO de forma sencilla y portable.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{CMSIS RTOS v2}: proporciona las funciones para crear y gestionar hilos, como \sphinxcode{\sphinxupquote{osThreadNew}} y \sphinxcode{\sphinxupquote{osDelay}}.

\end{itemize}


\section{Código}
\label{\detokenize{ejemplothreads:codigo}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZdq{}cmsis\PYGZus{}os2.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZdq{}stm32f4xx\PYGZus{}hal.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}stdlib.h\PYGZgt{}}

\PYG{n}{osThreadId\PYGZus{}t}\PYG{+w}{ }\PYG{n}{tid\PYGZus{}Thread}\PYG{p}{;}

\PYG{n}{GPIO\PYGZus{}InitTypeDef}\PYG{+w}{ }\PYG{n}{led\PYGZus{}ld1}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{p}{.}\PYG{n}{Pin}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{GPIO\PYGZus{}PIN\PYGZus{}0}\PYG{p}{,}
\PYG{+w}{    }\PYG{p}{.}\PYG{n}{Mode}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{GPIO\PYGZus{}MODE\PYGZus{}OUTPUT\PYGZus{}PP}\PYG{p}{,}
\PYG{+w}{    }\PYG{p}{.}\PYG{n}{Pull}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{GPIO\PYGZus{}NOPULL}\PYG{p}{,}
\PYG{+w}{    }\PYG{p}{.}\PYG{n}{Speed}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{GPIO\PYGZus{}SPEED\PYGZus{}FREQ\PYGZus{}LOW}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{n}{GPIO\PYGZus{}InitTypeDef}\PYG{+w}{ }\PYG{n}{led\PYGZus{}ld2}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{p}{.}\PYG{n}{Pin}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{GPIO\PYGZus{}PIN\PYGZus{}7}\PYG{p}{,}
\PYG{+w}{    }\PYG{p}{.}\PYG{n}{Mode}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{GPIO\PYGZus{}MODE\PYGZus{}OUTPUT\PYGZus{}PP}\PYG{p}{,}
\PYG{+w}{    }\PYG{p}{.}\PYG{n}{Pull}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{GPIO\PYGZus{}NOPULL}\PYG{p}{,}
\PYG{+w}{    }\PYG{p}{.}\PYG{n}{Speed}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{GPIO\PYGZus{}SPEED\PYGZus{}FREQ\PYGZus{}LOW}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{k}{typedef}\PYG{+w}{ }\PYG{k}{struct}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{GPIO\PYGZus{}InitTypeDef}\PYG{+w}{ }\PYG{n}{pin}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{GPIO\PYGZus{}TypeDef}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{port}\PYG{p}{;}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{delay}\PYG{p}{;}
\PYG{+w}{    }\PYG{k+kt}{uint8\PYGZus{}t}\PYG{+w}{ }\PYG{n}{counter}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{+w}{ }\PYG{n}{mygpio\PYGZus{}pin}\PYG{p}{;}

\PYG{n}{mygpio\PYGZus{}pin}\PYG{+w}{ }\PYG{n}{pinB0}\PYG{p}{;}
\PYG{n}{mygpio\PYGZus{}pin}\PYG{+w}{ }\PYG{n}{pinB7}\PYG{p}{;}

\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{Init\PYGZus{}Thread}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{\PYGZus{}\PYGZus{}HAL\PYGZus{}RCC\PYGZus{}GPIOB\PYGZus{}CLK\PYGZus{}ENABLE}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{    }\PYG{n}{pinB0}\PYG{p}{.}\PYG{n}{pin}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{led\PYGZus{}ld1}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{pinB0}\PYG{p}{.}\PYG{n}{port}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{GPIOB}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{pinB0}\PYG{p}{.}\PYG{n}{delay}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{15}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{pinB0}\PYG{p}{.}\PYG{n}{counter}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{tid\PYGZus{}Thread}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{osThreadNew}\PYG{p}{(}\PYG{n}{Thread}\PYG{p}{,}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{void}\PYG{+w}{ }\PYG{o}{*}\PYG{p}{)}\PYG{o}{\PYGZam{}}\PYG{n}{pinB0}\PYG{p}{,}\PYG{+w}{ }\PYG{n+nb}{NULL}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{tid\PYGZus{}Thread}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{n+nb}{NULL}\PYG{p}{)}\PYG{+w}{ }\PYG{k}{return}\PYG{+w}{ }\PYG{l+m+mi}{\PYGZhy{}1}\PYG{p}{;}

\PYG{+w}{    }\PYG{n}{pinB7}\PYG{p}{.}\PYG{n}{pin}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{led\PYGZus{}ld2}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{pinB7}\PYG{p}{.}\PYG{n}{port}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{GPIOB}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{pinB7}\PYG{p}{.}\PYG{n}{delay}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{10}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{pinB7}\PYG{p}{.}\PYG{n}{counter}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{tid\PYGZus{}Thread}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{osThreadNew}\PYG{p}{(}\PYG{n}{Thread}\PYG{p}{,}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{void}\PYG{+w}{ }\PYG{o}{*}\PYG{p}{)}\PYG{o}{\PYGZam{}}\PYG{n}{pinB7}\PYG{p}{,}\PYG{+w}{ }\PYG{n+nb}{NULL}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{tid\PYGZus{}Thread}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{n+nb}{NULL}\PYG{p}{)}\PYG{+w}{ }\PYG{k}{return}\PYG{+w}{ }\PYG{l+m+mi}{\PYGZhy{}1}\PYG{p}{;}

\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{Thread}\PYG{p}{(}\PYG{k+kt}{void}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{argument}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{mygpio\PYGZus{}pin}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{gpio}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{mygpio\PYGZus{}pin}\PYG{+w}{ }\PYG{o}{*}\PYG{p}{)}\PYG{n}{argument}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{HAL\PYGZus{}GPIO\PYGZus{}Init}\PYG{p}{(}\PYG{n}{gpio}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{port}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{p}{(}\PYG{n}{gpio}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{pin}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{gpio}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{counter}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{HAL\PYGZus{}GPIO\PYGZus{}TogglePin}\PYG{p}{(}\PYG{n}{gpio}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{port}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{gpio}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{pin}\PYG{p}{.}\PYG{n}{Pin}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{osDelay}\PYG{p}{(}\PYG{n}{gpio}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{delay}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\section{Dependencias software}
\label{\detokenize{ejemplothreads:dependencias-software}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Librería HAL de STM32.

\item {} 
\sphinxAtStartPar
CMSIS RTOS v2.

\end{itemize}


\section{Preguntas y respuestas sobre ejemplothreads}
\label{\detokenize{ejemplothreads:preguntas-y-respuestas-sobre-ejemplothreads}}
\sphinxAtStartPar
Esta sección contiene una serie de preguntas con sus respectivas respuestas sobre el funcionamiento del código que utiliza CMSIS RTOS v2 para controlar LEDs en una placa STM32.


\subsection{¿Qué función hace este código?}
\label{\detokenize{ejemplothreads:que-funcion-hace-este-codigo}}
\sphinxAtStartPar
Este código crea dos hilos (threads) que controlan dos LEDs conectados a los pines PB0 y PB7 de una placa STM32F4. Cada hilo alterna el estado del LED (encendido/apagado) con una frecuencia determinada utilizando funciones del sistema operativo en tiempo real CMSIS RTOS v2.
Es importante entender que el mismo código (funcion Thread) es ejecutado por dos hilos diferentes, cada uno con sus propios parámetros, que se reciben en el argumento de la función.
Es de tipo \sphinxcode{\sphinxupquote{void}} para poder pasar cualquier tipo de estructura como argumento. Dentro del código del Thread se realiza un casting al tipo de estructura que se utiliza en el ejemplo


\subsection{¿Qué  función tiene \sphinxtitleref{mygpio\_pin}?}
\label{\detokenize{ejemplothreads:que-funcion-tiene-mygpio-pin}}
\sphinxAtStartPar
Es una estructura de datos que encapsula la información necesaria para controlar un pin GPIO en este ejemplo:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pin}}: configuración del pin (tipo, velocidad, modo).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{port}}: puerto GPIO al que pertenece el pin (por ejemplo, GPIOB).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{delay}}: retardo en ms entre cada cambio de estado (toggle).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{counter}}: variable auxiliar que cuenta la cantidad de veces que se ha realizado el toggle.

\end{itemize}


\subsection{¿Cómo se inicializan los hilos?}
\label{\detokenize{ejemplothreads:como-se-inicializan-los-hilos}}
\sphinxAtStartPar
La función \sphinxcode{\sphinxupquote{Init\_Thread()}} habilita el reloj del puerto GPIOB, configura los parámetros de cada LED y crea dos hilos con \sphinxcode{\sphinxupquote{osThreadNew()}}, pasando como argumento la estructura \sphinxcode{\sphinxupquote{mygpio\_pin}} correspondiente a cada LED.


\subsection{¿Qué función tieneº \sphinxtitleref{Thread()}?}
\label{\detokenize{ejemplothreads:que-funcion-tieneo-thread}}
\sphinxAtStartPar
La función \sphinxcode{\sphinxupquote{Thread(void *argument)}} es ejecutada por cada hilo. Dentro de ella:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Se inicializa el pin GPIO usando \sphinxcode{\sphinxupquote{HAL\_GPIO\_Init}}.

\item {} 
\sphinxAtStartPar
Se entra en un bucle infinito donde:
\sphinxhyphen{} Se alterna el valor de \sphinxcode{\sphinxupquote{counter}}.
\sphinxhyphen{} Se cambia el estado del LED con \sphinxcode{\sphinxupquote{HAL\_GPIO\_TogglePin}}.
\sphinxhyphen{} Se espera el tiempo definido en \sphinxcode{\sphinxupquote{delay}} usando \sphinxcode{\sphinxupquote{osDelay}}.

\end{enumerate}


\subsection{¿Se ejecutan los hilos al mismo tiempo?}
\label{\detokenize{ejemplothreads:se-ejecutan-los-hilos-al-mismo-tiempo}}
\sphinxAtStartPar
CMSIS RTOS v2 permite la ejecución concurrente, que no simultanea, de múltiples hilos. El scheduler del sistema operativo se encarga de asignar tiempo de CPU a cada hilo según su estado y prioridad.


\subsection{¿Qué función tiene \sphinxstyleliteralintitle{\sphinxupquote{osDelay()}}}
\label{\detokenize{ejemplothreads:que-funcion-tiene-osdelay}}
\sphinxAtStartPar
Es una función del RTOS que suspende la ejecución del hilo actual durante un número determinado de ticks. Esto permite que otros hilos se ejecuten mientras tanto. \sphinxcode{\sphinxupquote{osDelay}} tiene como parametro el número de ticks que la tarea estará bloqueada. El número de ticks por segundo se define en el archivo \sphinxcode{\sphinxupquote{RTX\_Config.h}} (parámetro \sphinxcode{\sphinxupquote{Kernel Tick Frequency {[}Hz{]}}}). En este ejemplo se ha configurado a 1000, por lo que un tick equivale a 1 ms.


\subsection{¿Qué pasa si \sphinxtitleref{osThreadNew()} retorna NULL?}
\label{\detokenize{ejemplothreads:que-pasa-si-osthreadnew-retorna-null}}
\sphinxAtStartPar
Significa que no se pudo crear el hilo. En ese caso, la función \sphinxcode{\sphinxupquote{Init\_Thread()}} devuelve \sphinxstyleemphasis{\sphinxhyphen{}1} como señal de error.


\subsection{¿Qué includes se utilizan?}
\label{\detokenize{ejemplothreads:que-includes-se-utilizan}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{cmsis\_os2.h}}: para funciones del sistema operativo en tiempo real.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{stm32f4xx\_hal.h}}: para funciones de acceso a hardware (HAL).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{stdlib.h}}: para funciones estándar de C.

\end{itemize}


\subsection{¿Cuanto vale el valor del tick es esta aplicación?}
\label{\detokenize{ejemplothreads:cuanto-vale-el-valor-del-tick-es-esta-aplicacion}}
\sphinxAtStartPar
El fichero de configuración del sistema operativo tal y como indica la figura tiene configurado un tick de 1ms.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[scale=0.5]{{RTXConfig}.png}
\caption{Configuración del sistema operativo.}\label{\detokenize{ejemplothreads:id1}}\end{figure}


\subsection{¿Que es el thread Idle? ¿Qué tamaño de stack tiene? ¿Y otro thread? ¿Que tamaño de stack usa?}
\label{\detokenize{ejemplothreads:que-es-el-thread-idle-que-tamano-de-stack-tiene-y-otro-thread-que-tamano-de-stack-usa}}
\sphinxAtStartPar
El thread idle esta definido en el fichero RTX\_Config.c y es un thread que se ejecuta cuando el sistema operativo no tiene ninguna otro thread que ejecutar. Tiene un tamaño de \sphinxcode{\sphinxupquote{stack}} de 512 bytes.
Cualquier otro thread se configura para tener un tamaño de stack de 3072 bytes (3KBytes). Una reflexión interesante es cuantos threads se pueden crear en una aplicación.

\sphinxstepscope


\chapter{Uso básico de threads y colas en CMSIS RTOS v2}
\label{\detokenize{ejemplothreads-queues:uso-basico-de-threads-y-colas-en-cmsis-rtos-v2}}\label{\detokenize{ejemplothreads-queues::doc}}
\sphinxAtStartPar
Este documento describe el funcionamiento de un programa en C que utiliza CMSIS RTOS v2 y la biblioteca HAL de STM32 para controlar dos LEDs mediante hilos concurrentes que se comunican con colas.


\section{Descripción General}
\label{\detokenize{ejemplothreads-queues:descripcion-general}}
\sphinxAtStartPar
El programa crea dos hilos, denominados \sphinxcode{\sphinxupquote{Producer}} y \sphinxcode{\sphinxupquote{Consumer}}. El hilo \sphinxcode{\sphinxupquote{Producer}} se encarga de introducir datos en la cola que tiene el identificador \sphinxcode{\sphinxupquote{id\_MsgQueue}}.
El numero total de mensajes que se introducen en la cola en cada iteración del bucle \sphinxcode{\sphinxupquote{while}} es 32 con un tiempo de retardo entre operaciones de escritura que es variable
El \sphinxcode{\sphinxupquote{Consumer}} se encarga de extraer los datos de cola y de actuar sobre los leds en función del valor leido de la cola.


\section{Estructuras de Datos}
\label{\detokenize{ejemplothreads-queues:estructuras-de-datos}}
\sphinxAtStartPar
Se define una estructura llamada \sphinxcode{\sphinxupquote{mygpio\_pin}} que encapsula toda la información necesaria para controlar un LED:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{GPIO\_InitTypeDef pin}}: configuración del pin (modo, velocidad, tipo de salida).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{GPIO\_TypeDef *port}}: puerto GPIO al que pertenece el pin.

\end{itemize}

\sphinxAtStartPar
Esta estructura permite pasar todos los parámetros necesarios a la función del hilo de forma organizada.


\section{Creación Hilos}
\label{\detokenize{ejemplothreads-queues:creacion-hilos}}
\sphinxAtStartPar
La función \sphinxcode{\sphinxupquote{Init\_Thread}} realiza las siguientes operaciones:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Crea una cola con \sphinxcode{\sphinxupquote{osMessageQueueNew}} para almacenar hasta 16 mensajes cada uno de tamaño un \sphinxcode{\sphinxupquote{uint8\_t}}, es decir, un solo byte.

\item {} 
\sphinxAtStartPar
Crea un hilo \sphinxcode{\sphinxupquote{Consumer}} con \sphinxcode{\sphinxupquote{osThreadNew}}, ejecutando la función \sphinxcode{\sphinxupquote{Consumer}}.

\item {} 
\sphinxAtStartPar
Crea un hilo \sphinxcode{\sphinxupquote{Producer}} con \sphinxcode{\sphinxupquote{osThreadNew}}, ejecutando la función \sphinxcode{\sphinxupquote{Producer}}.

\end{enumerate}


\section{Producer}
\label{\detokenize{ejemplothreads-queues:producer}}
\sphinxAtStartPar
La función \sphinxcode{\sphinxupquote{Producer(void *argument)}} realiza las siguientes operaciones:
1. De manera continua en un bucle infinito inserta en cola en cada iteración del bucle while 32 mensajes de 1 byte con el valor de la variable index.
2. Los mensajes se introducen con un retardo que varia desde 100ms hasta 400ms
3. La función osMessageQueuePut introduce los mensajes con timeout 0, lo cúal implica que si no hay sitio en la cola el mensaje no se podrá guardar.


\section{Consumer}
\label{\detokenize{ejemplothreads-queues:consumer}}
\sphinxAtStartPar
La función \sphinxcode{\sphinxupquote{Consumer(void *argument)}} realiza las siguientes operaciones:
1. De manera continua en un bucle infinito extrae de la cola los mensajes introducidos por el hilo \sphinxcode{\sphinxupquote{Producer}}.
2. Si se saca un valor de la cola se procede a encender o apagar los leds en función del valor leido.
3. La variable errors\_or\_timeout cuenta el número de veces que no se ha podido leer un mensaje de la cola, ya sea por timeout o porque la cola está vacía.


\section{HAL\sphinxhyphen{}CMSIS RTOS}
\label{\detokenize{ejemplothreads-queues:hal-cmsis-rtos}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{HAL (Hardware Abstraction Layer)}: se utiliza para configurar e inicializar los pines GPIO de forma sencilla y portable.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{CMSIS RTOS v2}: proporciona las funciones para crear y gestionar hilos, como \sphinxcode{\sphinxupquote{osThreadNew}} y \sphinxcode{\sphinxupquote{osDelay}}, y las funciones para gestionar las colas.

\end{itemize}


\section{Fuente}
\label{\detokenize{ejemplothreads-queues:fuente}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZdq{}cmsis\PYGZus{}os2.h\PYGZdq{}}\PYG{c+c1}{                          // CMSIS RTOS header file}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZdq{}stm32f4xx\PYGZus{}hal.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}string.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}stdlib.h\PYGZgt{}}


\PYG{n}{osThreadId\PYGZus{}t}\PYG{+w}{ }\PYG{n}{tid\PYGZus{}Thread}\PYG{p}{;}\PYG{+w}{                        }\PYG{c+c1}{// thread id}
\PYG{n}{osMessageQueueId\PYGZus{}t}\PYG{+w}{ }\PYG{n}{id\PYGZus{}MsgQueue}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{Init\PYGZus{}Thread}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{Producer}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{void}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{argument}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{                   }\PYG{c+c1}{// thread function producing data}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{Consumer}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{void}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{argument}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{                   }\PYG{c+c1}{// thread function consuming data}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{qsize}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k+kt}{uint16\PYGZus{}t}\PYG{+w}{ }\PYG{n}{h}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k+kt}{uint8\PYGZus{}t}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}

\PYG{k}{typedef}\PYG{+w}{ }\PYG{k}{struct}\PYG{+w}{  }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{GPIO\PYGZus{}InitTypeDef}\PYG{+w}{ }\PYG{n}{pin}\PYG{p}{;}
\PYG{+w}{                }\PYG{n}{GPIO\PYGZus{}TypeDef}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{port}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{+w}{ }\PYG{n}{mygpio\PYGZus{}pin}\PYG{p}{;}

\PYG{n}{mygpio\PYGZus{}pin}\PYG{+w}{ }\PYG{n}{pinB0}\PYG{p}{;}
\PYG{n}{mygpio\PYGZus{}pin}\PYG{+w}{ }\PYG{n}{pinB7}\PYG{p}{;}

\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{Init\PYGZus{}Thread}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}

\PYG{+w}{        }\PYG{n}{id\PYGZus{}MsgQueue}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{osMessageQueueNew}\PYG{p}{(}\PYG{l+m+mi}{16}\PYG{p}{,}\PYG{+w}{ }\PYG{k}{sizeof}\PYG{p}{(}\PYG{k+kt}{uint8\PYGZus{}t}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n+nb}{NULL}\PYG{p}{)}\PYG{p}{;}


\PYG{n}{tid\PYGZus{}Thread}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{osThreadNew}\PYG{p}{(}\PYG{n}{Producer}\PYG{p}{,}\PYG{+w}{ }\PYG{n+nb}{NULL}\PYG{p}{,}\PYG{+w}{ }\PYG{n+nb}{NULL}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{tid\PYGZus{}Thread}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{n+nb}{NULL}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k}{return}\PYG{p}{(}\PYG{l+m+mi}{\PYGZhy{}1}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{+w}{        }\PYG{n}{tid\PYGZus{}Thread}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{osThreadNew}\PYG{p}{(}\PYG{n}{Consumer}\PYG{p}{,}\PYG{+w}{ }\PYG{n+nb}{NULL}\PYG{p}{,}\PYG{+w}{ }\PYG{n+nb}{NULL}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{tid\PYGZus{}Thread}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{n+nb}{NULL}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k}{return}\PYG{p}{(}\PYG{l+m+mi}{\PYGZhy{}1}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k}{return}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{Producer}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{void}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{argument}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k+kt}{uint8\PYGZus{}t}\PYG{+w}{ }\PYG{n}{index}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{osStatus\PYGZus{}t}\PYG{+w}{ }\PYG{n}{status}\PYG{p}{;}
\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{                }\PYG{k}{for}\PYG{p}{(}\PYG{+w}{ }\PYG{n}{h}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{h}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{5}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{h}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
\PYG{+w}{                        }\PYG{k}{for}\PYG{p}{(}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+m+mi}{8}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
\PYG{+w}{                                }\PYG{n}{status}\PYG{o}{=}\PYG{n}{osMessageQueuePut}\PYG{p}{(}\PYG{n}{id\PYGZus{}MsgQueue}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{index}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{0U}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{0U}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{                                }\PYG{n}{index}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
\PYG{+w}{                                }\PYG{n}{osDelay}\PYG{p}{(}\PYG{n}{h}\PYG{o}{*}\PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{                        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{                }\PYG{p}{\PYGZcb{}}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{Consumer}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{void}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{argument}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k+kt}{uint8\PYGZus{}t}\PYG{+w}{ }\PYG{n}{val}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{osStatus\PYGZus{}t}\PYG{+w}{ }\PYG{n}{status}\PYG{p}{;}
\PYG{+w}{        }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{errors\PYGZus{}or\PYGZus{}timeouts}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{GPIO\PYGZus{}InitTypeDef}\PYG{+w}{ }\PYG{n}{led\PYGZus{}ld1}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{                }\PYG{p}{.}\PYG{n}{Pin}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{GPIO\PYGZus{}PIN\PYGZus{}0}\PYG{p}{,}
\PYG{+w}{                }\PYG{p}{.}\PYG{n}{Mode}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{GPIO\PYGZus{}MODE\PYGZus{}OUTPUT\PYGZus{}PP}\PYG{p}{,}
\PYG{+w}{                }\PYG{p}{.}\PYG{n}{Pull}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{GPIO\PYGZus{}NOPULL}\PYG{p}{,}
\PYG{+w}{                }\PYG{p}{.}\PYG{n}{Speed}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{GPIO\PYGZus{}SPEED\PYGZus{}FREQ\PYGZus{}LOW}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{GPIO\PYGZus{}InitTypeDef}\PYG{+w}{ }\PYG{n}{led\PYGZus{}ld2}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{                }\PYG{p}{.}\PYG{n}{Pin}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{GPIO\PYGZus{}PIN\PYGZus{}7}\PYG{p}{,}
\PYG{+w}{                }\PYG{p}{.}\PYG{n}{Mode}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{GPIO\PYGZus{}MODE\PYGZus{}OUTPUT\PYGZus{}PP}\PYG{p}{,}
\PYG{+w}{                }\PYG{p}{.}\PYG{n}{Pull}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{GPIO\PYGZus{}NOPULL}\PYG{p}{,}
\PYG{+w}{                }\PYG{p}{.}\PYG{n}{Speed}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{GPIO\PYGZus{}SPEED\PYGZus{}FREQ\PYGZus{}LOW}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{\PYGZus{}\PYGZus{}HAL\PYGZus{}RCC\PYGZus{}GPIOB\PYGZus{}CLK\PYGZus{}ENABLE}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{        }\PYG{n}{HAL\PYGZus{}GPIO\PYGZus{}Init}\PYG{p}{(}\PYG{n}{GPIOB}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{led\PYGZus{}ld1}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{        }\PYG{n}{HAL\PYGZus{}GPIO\PYGZus{}Init}\PYG{p}{(}\PYG{n}{GPIOB}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{led\PYGZus{}ld2}\PYG{p}{)}\PYG{p}{;}


\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{qsize}\PYG{o}{=}\PYG{n}{osMessageQueueGetCount}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{id\PYGZus{}MsgQueue}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{                }\PYG{n}{status}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{osMessageQueueGet}\PYG{p}{(}\PYG{n}{id\PYGZus{}MsgQueue}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{val}\PYG{p}{,}\PYG{+w}{ }\PYG{n+nb}{NULL}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{10U}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{   }\PYG{c+c1}{// wait for message}
\PYG{+w}{                }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{status}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{osOK}\PYG{p}{)}\PYG{p}{\PYGZob{}}
\PYG{+w}{                        }\PYG{n}{HAL\PYGZus{}GPIO\PYGZus{}WritePin}\PYG{p}{(}\PYG{n}{GPIOB}\PYG{p}{,}\PYG{n}{led\PYGZus{}ld1}\PYG{p}{.}\PYG{n}{Pin}\PYG{p}{,}\PYG{p}{(}\PYG{n}{GPIO\PYGZus{}PinState}\PYG{p}{)}\PYG{+w}{ }\PYG{n}{val}\PYG{o}{\PYGZam{}}\PYG{l+m+mh}{0x01}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{                        }\PYG{n}{HAL\PYGZus{}GPIO\PYGZus{}WritePin}\PYG{p}{(}\PYG{n}{GPIOB}\PYG{p}{,}\PYG{n}{led\PYGZus{}ld2}\PYG{p}{.}\PYG{n}{Pin}\PYG{p}{,}\PYG{p}{(}\PYG{n}{GPIO\PYGZus{}PinState}\PYG{p}{)}\PYG{p}{(}\PYG{n}{val}\PYG{o}{\PYGZam{}}\PYG{l+m+mh}{0x02}\PYG{p}{)}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{                }\PYG{p}{\PYGZcb{}}
\PYG{+w}{                }\PYG{k}{else}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{                        }\PYG{n}{errors\PYGZus{}or\PYGZus{}timeouts}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
\PYG{+w}{                }\PYG{p}{\PYGZcb{}}
\PYG{+w}{                }\PYG{n}{osDelay}\PYG{p}{(}\PYG{l+m+mi}{250}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{//This delay is to simulate an operation that needs 101ms to complete}

\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\section{Dependencias de software}
\label{\detokenize{ejemplothreads-queues:dependencias-de-software}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Librería HAL de STM32.

\item {} 
\sphinxAtStartPar
CMSIS RTOS v2.

\end{itemize}


\section{Preguntas y respuestas sobre ejemplothreads\sphinxhyphen{}queues}
\label{\detokenize{ejemplothreads-queues:preguntas-y-respuestas-sobre-ejemplothreads-queues}}
\sphinxAtStartPar
Esta sección contiene una serie de preguntas con sus respectivas respuestas sobre el funcionamiento del código que utiliza CMSIS RTOS v2 para controlar LEDs en una placa STM32.


\subsection{¿Cuál es el propósito de la cola de mensajes \sphinxtitleref{id\_MsgQueue} en esta aplicación?}
\label{\detokenize{ejemplothreads-queues:cual-es-el-proposito-de-la-cola-de-mensajes-id-msgqueue-en-esta-aplicacion}}
\sphinxAtStartPar
La cola de mensajes \sphinxtitleref{id\_MsgQueue} actúa como un canal de comunicación y sincronización entre los hilos \sphinxtitleref{Producer} y \sphinxtitleref{Consumer}. Permite que el hilo productor envíe datos (índices) al consumidor de forma segura y sincronizada. Al definir una cola con capacidad para 16 elementos de tipo \sphinxtitleref{uint8\_t}, se establece un buffer temporal que desacopla la producción y el consumo de datos.


\subsection{¿Qué función cumple el bucle anidado en el hilo \sphinxtitleref{Producer}?}
\label{\detokenize{ejemplothreads-queues:que-funcion-cumple-el-bucle-anidado-en-el-hilo-producer}}
\sphinxAtStartPar
El bucle anidado en \sphinxtitleref{Producer} genera una secuencia de valores que se colocan en la cola de mensajes. El bucle externo recorre \sphinxtitleref{h} de 1 a 4, y el interno recorre \sphinxtitleref{i} de 0 a 7. En cada iteración, se coloca un valor en la cola (\sphinxtitleref{index}) y se incrementa. El retardo \sphinxtitleref{osDelay(h*100)} introduce una variabilidad en el tiempo entre envíos, oscilando entre 100 ms y 400 ms. Esto simula diferentes tasas de producción de datos.


\subsection{¿Cuanto tiempo tarda en llenarse la cola de mensajes \sphinxtitleref{id\_MsgQueue}?}
\label{\detokenize{ejemplothreads-queues:cuanto-tiempo-tarda-en-llenarse-la-cola-de-mensajes-id-msgqueue}}
\sphinxAtStartPar
En la cola se introducen 32 mensajes en cada ciclo completo de los bucles anidados (8 mensajes por cada uno de los 4 valores de \sphinxtitleref{h}) pero el Thread Consumer extrae mensajes cada 250ms en el caso de que existan. Por tanto la cola nunca llega a llenarse.
Intente calcular cual sería el numero máximo de mensajes que se pueden acumular en la cola.


\subsection{¿cuanto vale la variable errors\_or\_timeouts despues de 1 minuto de ejecución del código?}
\label{\detokenize{ejemplothreads-queues:cuanto-vale-la-variable-errors-or-timeouts-despues-de-1-minuto-de-ejecucion-del-codigo}}
\sphinxAtStartPar
Vale 0 porque no se produce dicha condición nunca.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Challenge: Modifique el código del hilo \sphinxcode{\sphinxupquote{Producer}} para que la variable errors\_or\_timeouts no valga cero.
\end{sphinxadmonition}

\sphinxstepscope


\chapter{Uso básico de threads y flags en CMSIS RTOS v2}
\label{\detokenize{ejemplothreads-flags:uso-basico-de-threads-y-flags-en-cmsis-rtos-v2}}\label{\detokenize{ejemplothreads-flags::doc}}
\sphinxAtStartPar
Este documento describe el funcionamiento de un programa en C que utiliza CMSIS RTOS v2 y la biblioteca HAL de STM32 para controlar dos LEDs mediante hilos concurrentes que se sincronizan con flags.


\section{Descripción}
\label{\detokenize{ejemplothreads-flags:descripcion}}
\sphinxAtStartPar
El programa crea dos hilos, denominados \sphinxcode{\sphinxupquote{Producer}} y \sphinxcode{\sphinxupquote{Consumer}}.  El hilo \sphinxcode{\sphinxupquote{Producer}} es un bucle infinito que se encarga de activar flags para el thread \sphinxcode{\sphinxupquote{Consumer}}. Este en función de los flags activados ejecuta unas acciones u otras.

\sphinxAtStartPar
Se define una estructura llamada \sphinxcode{\sphinxupquote{mygpio\_pin}} que encapsula toda la información necesaria para controlar un LED:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{GPIO\_InitTypeDef pin}}: configuración del pin (modo, velocidad, tipo de salida).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{GPIO\_TypeDef *port}}: puerto GPIO al que pertenece el pin.

\end{itemize}

\sphinxAtStartPar
Esta estructura permite pasar todos los parámetros necesarios a la función del hilo de forma organizada.

\sphinxAtStartPar
La función \sphinxcode{\sphinxupquote{Init\_Thread}} realiza las siguientes operaciones:

\sphinxAtStartPar
1. Crea un hilo \sphinxcode{\sphinxupquote{Consumer}} con \sphinxcode{\sphinxupquote{osThreadNew}}, ejecutando la función \sphinxcode{\sphinxupquote{Consumer}}.
3. Crea un hilo \sphinxcode{\sphinxupquote{Producer}} con \sphinxcode{\sphinxupquote{osThreadNew}}, ejecutando la función \sphinxcode{\sphinxupquote{Producer}}.


\section{Función del hilo Producer}
\label{\detokenize{ejemplothreads-flags:funcion-del-hilo-producer}}
\sphinxAtStartPar
La función \sphinxcode{\sphinxupquote{Producer(void *argument)}} realiza las siguientes operaciones:
1. De manera continua en un bucle infinito señaliza flags en el thread \sphinxcode{\sphinxupquote{Consumer}}.
2. Los flags activados son el 0x0001 y en 0x0002.


\section{Función del hilo Consumer}
\label{\detokenize{ejemplothreads-flags:funcion-del-hilo-consumer}}
\sphinxAtStartPar
La función \sphinxcode{\sphinxupquote{Consumer(void *argument)}} realiza las siguientes operaciones:
1. Inticializa  dos pines del GPIO en el puerto B.
2. Espera de manera infinita (\sphinxcode{\sphinxupquote{osWaitForEver}}) a que cualquiera  (\sphinxcode{\sphinxupquote{osFlagsWaitAny}}) de los flags (\sphinxcode{\sphinxupquote{0}} o \sphinxcode{\sphinxupquote{1}}, en hexadecimal \sphinxcode{\sphinxupquote{0x03}}) se activen.
3. Si el flag activado es el \sphinxcode{\sphinxupquote{0}} se hace un toggle en el pin 0 del GPIOB. Si el activado es el \sphinxcode{\sphinxupquote{1}} se hace el toggle en el pin 7 del GPIOB.
4. Si se produce otra condición se incrementa la variable \sphinxcode{\sphinxupquote{errors}}.


\section{HAL y CMSIS RTOS}
\label{\detokenize{ejemplothreads-flags:hal-y-cmsis-rtos}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{HAL (Hardware Abstraction Layer)}: se utiliza para configurar e inicializar los pines GPIO de forma sencilla y portable.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{CMSIS RTOS v2}: proporciona las funciones para crear y gestionar hilos, como \sphinxcode{\sphinxupquote{osThreadNew}} y \sphinxcode{\sphinxupquote{osDelay}}, y la funciones de gestion de los flags.

\end{itemize}


\section{Código aplicación}
\label{\detokenize{ejemplothreads-flags:codigo-aplicacion}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZdq{}cmsis\PYGZus{}os2.h\PYGZdq{}}\PYG{c+c1}{                          // CMSIS RTOS header file}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZdq{}stm32f4xx\PYGZus{}hal.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}string.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}stdlib.h\PYGZgt{}}


\PYG{n}{osThreadId\PYGZus{}t}\PYG{+w}{ }\PYG{n}{tid\PYGZus{}Thread\PYGZus{}producer}\PYG{p}{;}\PYG{+w}{                        }\PYG{c+c1}{// thread id}
\PYG{n}{osThreadId\PYGZus{}t}\PYG{+w}{ }\PYG{n}{tid\PYGZus{}Thread\PYGZus{}consumer}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{Init\PYGZus{}Thread}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{Producer}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{void}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{argument}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{                   }\PYG{c+c1}{// thread function producing data}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{Consumer}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{void}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{argument}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{                   }\PYG{c+c1}{// thread function consuming data}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{qsize}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k+kt}{uint8\PYGZus{}t}\PYG{+w}{ }\PYG{n}{a}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k+kt}{uint8\PYGZus{}t}\PYG{+w}{ }\PYG{n}{b}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}

\PYG{k}{typedef}\PYG{+w}{ }\PYG{k}{struct}\PYG{+w}{  }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{GPIO\PYGZus{}InitTypeDef}\PYG{+w}{ }\PYG{n}{pin}\PYG{p}{;}
\PYG{+w}{                }\PYG{n}{GPIO\PYGZus{}TypeDef}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{port}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{+w}{ }\PYG{n}{mygpio\PYGZus{}pin}\PYG{p}{;}

\PYG{n}{mygpio\PYGZus{}pin}\PYG{+w}{ }\PYG{n}{pinB0}\PYG{p}{;}
\PYG{n}{mygpio\PYGZus{}pin}\PYG{+w}{ }\PYG{n}{pinB7}\PYG{p}{;}

\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{Init\PYGZus{}Thread}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}




\PYG{n}{tid\PYGZus{}Thread\PYGZus{}producer}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{osThreadNew}\PYG{p}{(}\PYG{n}{Producer}\PYG{p}{,}\PYG{+w}{ }\PYG{n+nb}{NULL}\PYG{p}{,}\PYG{+w}{ }\PYG{n+nb}{NULL}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{tid\PYGZus{}Thread\PYGZus{}producer}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{n+nb}{NULL}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k}{return}\PYG{p}{(}\PYG{l+m+mi}{\PYGZhy{}1}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{+w}{        }\PYG{n}{tid\PYGZus{}Thread\PYGZus{}consumer}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{osThreadNew}\PYG{p}{(}\PYG{n}{Consumer}\PYG{p}{,}\PYG{+w}{ }\PYG{n+nb}{NULL}\PYG{p}{,}\PYG{+w}{ }\PYG{n+nb}{NULL}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{tid\PYGZus{}Thread\PYGZus{}consumer}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{n+nb}{NULL}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k}{return}\PYG{p}{(}\PYG{l+m+mi}{\PYGZhy{}1}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k}{return}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{Producer}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{void}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{argument}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}

\PYG{+w}{        }\PYG{k+kt}{uint32\PYGZus{}t}\PYG{+w}{ }\PYG{n}{status}\PYG{p}{;}
\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}


\PYG{+w}{        }\PYG{n}{status}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{osThreadFlagsSet}\PYG{p}{(}\PYG{n}{tid\PYGZus{}Thread\PYGZus{}consumer}\PYG{p}{,}\PYG{l+m+mh}{0x0001}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{osDelay}\PYG{p}{(}\PYG{l+m+mi}{1000}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{status}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{osThreadFlagsSet}\PYG{p}{(}\PYG{n}{tid\PYGZus{}Thread\PYGZus{}consumer}\PYG{p}{,}\PYG{l+m+mh}{0x0002}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{osDelay}\PYG{p}{(}\PYG{l+m+mi}{1000}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{Consumer}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{void}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{argument}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k+kt}{uint8\PYGZus{}t}\PYG{+w}{ }\PYG{n}{val}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{+w}{        }\PYG{k+kt}{uint32\PYGZus{}t}\PYG{+w}{ }\PYG{n}{status}\PYG{p}{;}
\PYG{+w}{        }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{errors}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{GPIO\PYGZus{}InitTypeDef}\PYG{+w}{ }\PYG{n}{led\PYGZus{}ld1}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{                }\PYG{p}{.}\PYG{n}{Pin}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{GPIO\PYGZus{}PIN\PYGZus{}0}\PYG{p}{,}
\PYG{+w}{                }\PYG{p}{.}\PYG{n}{Mode}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{GPIO\PYGZus{}MODE\PYGZus{}OUTPUT\PYGZus{}PP}\PYG{p}{,}
\PYG{+w}{                }\PYG{p}{.}\PYG{n}{Pull}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{GPIO\PYGZus{}NOPULL}\PYG{p}{,}
\PYG{+w}{                }\PYG{p}{.}\PYG{n}{Speed}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{GPIO\PYGZus{}SPEED\PYGZus{}FREQ\PYGZus{}LOW}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{GPIO\PYGZus{}InitTypeDef}\PYG{+w}{ }\PYG{n}{led\PYGZus{}ld2}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{                }\PYG{p}{.}\PYG{n}{Pin}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{GPIO\PYGZus{}PIN\PYGZus{}7}\PYG{p}{,}
\PYG{+w}{                }\PYG{p}{.}\PYG{n}{Mode}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{GPIO\PYGZus{}MODE\PYGZus{}OUTPUT\PYGZus{}PP}\PYG{p}{,}
\PYG{+w}{                }\PYG{p}{.}\PYG{n}{Pull}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{GPIO\PYGZus{}NOPULL}\PYG{p}{,}
\PYG{+w}{                }\PYG{p}{.}\PYG{n}{Speed}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{GPIO\PYGZus{}SPEED\PYGZus{}FREQ\PYGZus{}LOW}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{\PYGZus{}\PYGZus{}HAL\PYGZus{}RCC\PYGZus{}GPIOB\PYGZus{}CLK\PYGZus{}ENABLE}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{        }\PYG{n}{HAL\PYGZus{}GPIO\PYGZus{}Init}\PYG{p}{(}\PYG{n}{GPIOB}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{led\PYGZus{}ld1}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{        }\PYG{n}{HAL\PYGZus{}GPIO\PYGZus{}Init}\PYG{p}{(}\PYG{n}{GPIOB}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{led\PYGZus{}ld2}\PYG{p}{)}\PYG{p}{;}


\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{status}\PYG{o}{=}\PYG{n}{osThreadFlagsWait}\PYG{p}{(}\PYG{l+m+mh}{0x3}\PYG{p}{,}\PYG{n}{osFlagsWaitAny}\PYG{p}{,}\PYG{n}{osWaitForever}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{                }\PYG{k}{switch}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{status}\PYG{p}{)}\PYG{p}{\PYGZob{}}
\PYG{+w}{                        }\PYG{k}{case}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{:}
\PYG{+w}{                                }\PYG{n}{HAL\PYGZus{}GPIO\PYGZus{}TogglePin}\PYG{p}{(}\PYG{n}{GPIOB}\PYG{p}{,}\PYG{n}{led\PYGZus{}ld1}\PYG{p}{.}\PYG{n}{Pin}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{                                }\PYG{n}{a}\PYG{o}{=}\PYG{o}{!}\PYG{n}{a}\PYG{p}{;}
\PYG{+w}{                                }\PYG{k}{break}\PYG{p}{;}
\PYG{+w}{                }\PYG{k}{case}\PYG{+w}{ }\PYG{l+m+mi}{2}\PYG{p}{:}
\PYG{+w}{                                }\PYG{n}{HAL\PYGZus{}GPIO\PYGZus{}TogglePin}\PYG{p}{(}\PYG{n}{GPIOB}\PYG{p}{,}\PYG{n}{led\PYGZus{}ld2}\PYG{p}{.}\PYG{n}{Pin}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{                        }\PYG{n}{b}\PYG{o}{=}\PYG{o}{!}\PYG{n}{b}\PYG{p}{;}
\PYG{+w}{                                }\PYG{k}{break}\PYG{p}{;}
\PYG{+w}{                }\PYG{k}{default}\PYG{o}{:}\PYG{n}{errors}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
\PYG{+w}{                                }\PYG{k}{break}\PYG{p}{;}
\PYG{+w}{                }\PYG{p}{\PYGZcb{}}


\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\section{Dependencias de software del ejemplo}
\label{\detokenize{ejemplothreads-flags:dependencias-de-software-del-ejemplo}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Librería HAL de STM32.

\item {} 
\sphinxAtStartPar
CMSIS RTOS v2.

\end{itemize}


\section{Preguntas y respuestas sobre ejemplothreads\sphinxhyphen{}flags}
\label{\detokenize{ejemplothreads-flags:preguntas-y-respuestas-sobre-ejemplothreads-flags}}
\sphinxAtStartPar
Esta sección contiene una serie de preguntas con sus respectivas respuestas sobre el funcionamiento del código que utiliza CMSIS RTOS v2 para controlar LEDs en una placa STM32.


\subsection{Se modifica el código del Producer para que envíe ambas señales (0x0001 y 0x0002) de forma casi simultánea, seguido de un delay de 1 segundo:}
\label{\detokenize{ejemplothreads-flags:se-modifica-el-codigo-del-producer-para-que-envie-ambas-senales-0x0001-y-0x0002-de-forma-casi-simultanea-seguido-de-un-delay-de-1-segundo}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{Producer}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{void}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{argument}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k+kt}{uint32\PYGZus{}t}\PYG{+w}{ }\PYG{n}{status}\PYG{p}{;}
\PYG{+w}{        }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{                }\PYG{n}{status}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{osThreadFlagsSet}\PYG{p}{(}\PYG{n}{tid\PYGZus{}Thread\PYGZus{}consumer}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mh}{0x0001}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{                }\PYG{n}{status}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{osThreadFlagsSet}\PYG{p}{(}\PYG{n}{tid\PYGZus{}Thread\PYGZus{}consumer}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mh}{0x0002}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{                }\PYG{n}{osDelay}\PYG{p}{(}\PYG{l+m+mi}{1000}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Analice el comportamiento resultante del sistema y responda:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
¿Qué valor tendría la variable status en el Consumer después de osThreadFlagsWait?

\item {} 
\sphinxAtStartPar
¿Cómo afecta esta modificación al parpadeo de los LEDs?

\end{enumerate}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Valor de status: La variable status en el Consumer tendría el valor 0x0003 (0x0001 | 0x0002), ya que los flags se acumulan en el sistema CMSIS\sphinxhyphen{}RTOS cuando se envían antes de que el thread destino los procese.

\item {} 
\sphinxAtStartPar
Efecto en los LEDs: Los LEDs dejarían de parpadear por completo. El switch statement en el Consumer solo maneja explícitamente los casos 1 (0x0001) y 2 (0x0002). Al recibir el valor combinado 3, la ejecución cae en el caso default, donde solo se incrementa la variable errors sin ejecutar ninguna operación de toggle en los GPIOs.

\end{enumerate}

\sphinxstepscope


\chapter{Uso básico de threads y software timers en CMSIS RTOS v2}
\label{\detokenize{ejemplothreads-software-timers:uso-basico-de-threads-y-software-timers-en-cmsis-rtos-v2}}\label{\detokenize{ejemplothreads-software-timers::doc}}
\sphinxAtStartPar
Esta sección describe el funcionamiento de un programa en C que utiliza CMSIS RTOS v2 y la biblioteca HAL de STM32 para controlar dos LEDs mediante un hilo y timers software.


\section{Descripción General}
\label{\detokenize{ejemplothreads-software-timers:descripcion-general}}
\sphinxAtStartPar
El programa crea un único hilo denominado \sphinxcode{\sphinxupquote{Timers}}. Este hilo se encarga de configurar los pines B0 y B7 como salida para excitar los LEDs LD1 y LD2. Ademas crea un timer one\sphinxhyphen{}shot y otro periodico.
El timer one\sphinxhyphen{}shot se inicia para que al cabo de 10 segundos se active y en su callback se encienda el led LD1 y se inicie el timer periódico. El timer periódico hace que el led LD2 parpadee cada 500ms.

\sphinxAtStartPar
Se define una estructura llamada \sphinxcode{\sphinxupquote{mygpio\_pin}} que encapsula toda la información necesaria para controlar un LED:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{GPIO\_InitTypeDef pin}}: configuración del pin (modo, velocidad, tipo de salida).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{GPIO\_TypeDef *port}}: puerto GPIO al que pertenece el pin.

\end{itemize}

\sphinxAtStartPar
La función \sphinxcode{\sphinxupquote{Init\_Thread}} realiza las siguientes operaciones:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Crea un hilo \sphinxcode{\sphinxupquote{Timers}} con \sphinxcode{\sphinxupquote{osThreadNew}}.

\end{enumerate}


\section{Función del Hilo \sphinxstyleliteralintitle{\sphinxupquote{Timers}}}
\label{\detokenize{ejemplothreads-software-timers:funcion-del-hilo-timers}}\begin{description}
\sphinxlineitem{La función \sphinxcode{\sphinxupquote{Timers(void *arg)}} realiza las siguientes operaciones:}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Configura los pines GPIO para los LEDs LD1 y LD2.

\item {} 
\sphinxAtStartPar
Ejecuta un bucle infinito que en cada iteración expera 1 segundo.

\end{enumerate}

\end{description}


\section{Uso de HAL y CMSIS RTOS}
\label{\detokenize{ejemplothreads-software-timers:uso-de-hal-y-cmsis-rtos}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{HAL (Hardware Abstraction Layer)}: se utiliza para configurar e inicializar los pines GPIO de forma sencilla y portable.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{CMSIS RTOS v2}: proporciona las funciones para crear y gestionar hilos, como \sphinxcode{\sphinxupquote{osThreadNew}} y \sphinxcode{\sphinxupquote{osDelay}}, y funciones específicas para gestionar timers.

\end{itemize}


\section{Código específico}
\label{\detokenize{ejemplothreads-software-timers:codigo-especifico}}
\fvset{hllines={, 49,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZdq{}cmsis\PYGZus{}os2.h\PYGZdq{}}\PYG{c+c1}{                          // CMSIS RTOS header file}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZdq{}stm32f4xx\PYGZus{}hal.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}string.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}stdlib.h\PYGZgt{}}


\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{Init\PYGZus{}Threads}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{Timers}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{void}\PYG{o}{*}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{GPIO\PYGZus{}InitTypeDef}\PYG{+w}{ }\PYG{n}{led\PYGZus{}ld1}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{                }\PYG{p}{.}\PYG{n}{Pin}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{GPIO\PYGZus{}PIN\PYGZus{}0}\PYG{p}{,}
\PYG{+w}{                }\PYG{p}{.}\PYG{n}{Mode}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{GPIO\PYGZus{}MODE\PYGZus{}OUTPUT\PYGZus{}PP}\PYG{p}{,}
\PYG{+w}{                }\PYG{p}{.}\PYG{n}{Pull}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{GPIO\PYGZus{}NOPULL}\PYG{p}{,}
\PYG{+w}{                }\PYG{p}{.}\PYG{n}{Speed}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{GPIO\PYGZus{}SPEED\PYGZus{}FREQ\PYGZus{}LOW}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{GPIO\PYGZus{}InitTypeDef}\PYG{+w}{ }\PYG{n}{led\PYGZus{}ld2}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{                }\PYG{p}{.}\PYG{n}{Pin}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{GPIO\PYGZus{}PIN\PYGZus{}7}\PYG{p}{,}
\PYG{+w}{                }\PYG{p}{.}\PYG{n}{Mode}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{GPIO\PYGZus{}MODE\PYGZus{}OUTPUT\PYGZus{}PP}\PYG{p}{,}
\PYG{+w}{                }\PYG{p}{.}\PYG{n}{Pull}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{GPIO\PYGZus{}NOPULL}\PYG{p}{,}
\PYG{+w}{                }\PYG{p}{.}\PYG{n}{Speed}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{GPIO\PYGZus{}SPEED\PYGZus{}FREQ\PYGZus{}LOW}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}\PYG{p}{;}


\PYG{k}{typedef}\PYG{+w}{ }\PYG{k}{struct}\PYG{+w}{  }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{GPIO\PYGZus{}InitTypeDef}\PYG{+w}{ }\PYG{n}{pin}\PYG{p}{;}
\PYG{+w}{                }\PYG{n}{GPIO\PYGZus{}TypeDef}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{port}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{+w}{ }\PYG{n}{mygpio\PYGZus{}pin}\PYG{p}{;}

\PYG{n}{mygpio\PYGZus{}pin}\PYG{+w}{ }\PYG{n}{pinB0}\PYG{p}{;}
\PYG{n}{mygpio\PYGZus{}pin}\PYG{+w}{ }\PYG{n}{pinB7}\PYG{p}{;}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{Timer1\PYGZus{}Callback\PYGZus{}1}\PYG{p}{(}\PYG{k+kt}{void}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{arg}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{Timer1\PYGZus{}Callback\PYGZus{}2}\PYG{p}{(}\PYG{k+kt}{void}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{arg}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{osTimerId\PYGZus{}t}\PYG{+w}{ }\PYG{n}{timsoft2}\PYG{+w}{ }\PYG{p}{;}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{Init\PYGZus{}Threads}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{osThreadId\PYGZus{}t}\PYG{+w}{ }\PYG{n}{tid\PYGZus{}Thread}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{osThreadNew}\PYG{p}{(}\PYG{n}{Timers}\PYG{p}{,}\PYG{+w}{ }\PYG{n+nb}{NULL}\PYG{p}{,}\PYG{+w}{ }\PYG{n+nb}{NULL}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{Timers}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{void}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{arg}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}


\PYG{+w}{        }\PYG{n}{\PYGZus{}\PYGZus{}HAL\PYGZus{}RCC\PYGZus{}GPIOB\PYGZus{}CLK\PYGZus{}ENABLE}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{        }\PYG{n}{HAL\PYGZus{}GPIO\PYGZus{}Init}\PYG{p}{(}\PYG{n}{GPIOB}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{led\PYGZus{}ld1}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{        }\PYG{n}{HAL\PYGZus{}GPIO\PYGZus{}Init}\PYG{p}{(}\PYG{n}{GPIOB}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{led\PYGZus{}ld2}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{HAL\PYGZus{}GPIO\PYGZus{}WritePin}\PYG{p}{(}\PYG{n}{GPIOB}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{led\PYGZus{}ld1}\PYG{p}{.}\PYG{n}{Pin}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{GPIO\PYGZus{}PIN\PYGZus{}RESET}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{HAL\PYGZus{}GPIO\PYGZus{}WritePin}\PYG{p}{(}\PYG{n}{GPIOB}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{led\PYGZus{}ld2}\PYG{p}{.}\PYG{n}{Pin}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{GPIO\PYGZus{}PIN\PYGZus{}RESET}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{        }\PYG{n}{osTimerId\PYGZus{}t}\PYG{+w}{ }\PYG{n}{timsoft1}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{osTimerNew}\PYG{p}{(}\PYG{n}{Timer1\PYGZus{}Callback\PYGZus{}1}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{osTimerOnce}\PYG{p}{,}\PYG{+w}{ }\PYG{n+nb}{NULL}\PYG{p}{,}\PYG{+w}{ }\PYG{n+nb}{NULL}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{        }\PYG{n}{osTimerStart}\PYG{p}{(}\PYG{n}{timsoft1}\PYG{p}{,}\PYG{l+m+mi}{10000}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{timsoft2}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{osTimerNew}\PYG{p}{(}\PYG{n}{Timer1\PYGZus{}Callback\PYGZus{}2}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{osTimerPeriodic}\PYG{p}{,}\PYG{+w}{ }\PYG{n+nb}{NULL}\PYG{p}{,}\PYG{+w}{ }\PYG{n+nb}{NULL}\PYG{p}{)}\PYG{p}{;}


\PYG{k}{while}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}
\PYG{+w}{                }\PYG{n}{osDelay}\PYG{p}{(}\PYG{l+m+mi}{1000}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{Timer1\PYGZus{}Callback\PYGZus{}1}\PYG{p}{(}\PYG{k+kt}{void}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{arg}\PYG{p}{)}\PYG{p}{\PYGZob{}}

\PYG{+w}{                        }\PYG{n}{HAL\PYGZus{}GPIO\PYGZus{}TogglePin}\PYG{p}{(}\PYG{n}{GPIOB}\PYG{p}{,}\PYG{n}{led\PYGZus{}ld1}\PYG{p}{.}\PYG{n}{Pin}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{                        }\PYG{n}{osTimerStart}\PYG{p}{(}\PYG{n}{timsoft2}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{500}\PYG{p}{)}\PYG{p}{;}

\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{Timer1\PYGZus{}Callback\PYGZus{}2}\PYG{p}{(}\PYG{k+kt}{void}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{arg}\PYG{p}{)}\PYG{p}{\PYGZob{}}

\PYG{+w}{                        }\PYG{n}{HAL\PYGZus{}GPIO\PYGZus{}TogglePin}\PYG{p}{(}\PYG{n}{GPIOB}\PYG{p}{,}\PYG{n}{led\PYGZus{}ld2}\PYG{p}{.}\PYG{n}{Pin}\PYG{p}{)}\PYG{p}{;}

\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\sphinxresetverbatimhllines


\section{Dependencia}
\label{\detokenize{ejemplothreads-software-timers:dependencia}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Librería HAL de STM32.

\item {} 
\sphinxAtStartPar
CMSIS RTOS v2.

\end{itemize}


\section{Preguntas y respuestas sobre ejemplothreads\sphinxhyphen{}timers}
\label{\detokenize{ejemplothreads-software-timers:preguntas-y-respuestas-sobre-ejemplothreads-timers}}
\sphinxAtStartPar
Esta sección contiene una serie de preguntas con sus respectivas respuestas sobre el funcionamiento del código que utiliza CMSIS RTOS v2 para controlar LEDs en una placa STM32.


\subsection{¿Cual es la diferencia fundamental entre un timer periódico otro one\sphinxhyphen{}shot?}
\label{\detokenize{ejemplothreads-software-timers:cual-es-la-diferencia-fundamental-entre-un-timer-periodico-otro-one-shot}}
\sphinxAtStartPar
El timer one\sphinxhyphen{}shot dispara la función de callback una sola vez. Es importante indicar que el tiempo empieza a contar desde que el timer es arrancado.
Un timer periódico por contra ejecuta la función de callback multiples veces.
Es importante hacer notar que la función de arrancar un timer no se puede llamar desde una rutina de atención a la interrupción.
La función de arrancar un timer se puede llamar de manera reiterada reiniciando la cuenta de tiempo del mismo.


\subsection{Los ficheros RTX\_config.h y RTX\_config.c son generados automáticamente por el entorno de desarrollo. ¿Se pueden modificar?}
\label{\detokenize{ejemplothreads-software-timers:los-ficheros-rtx-config-h-y-rtx-config-c-son-generados-automaticamente-por-el-entorno-de-desarrollo-se-pueden-modificar}}
\sphinxAtStartPar
Sí, se pueden modificar. Estos ficheros contienen configuraciones específicas del sistema operativo en tiempo real (RTOS) RTX, como el número máximo de hilos, la prioridad de los hilos, el tamaño de la pila, entre otros parámetros.
Modificar estos archivos permite ajustar el comportamiento del RTOS según las necesidades específicas de la aplicación.


\subsection{Si se fija un punto de ruptura en la línea 47, ¿qué se espera ver en el \sphinxstyleliteralintitle{\sphinxupquote{Watch Windows\sphinxhyphen{}\textgreater{}RTX RTOS}}?}
\label{\detokenize{ejemplothreads-software-timers:si-se-fija-un-punto-de-ruptura-en-la-linea-47-que-se-espera-ver-en-el-watch-windows-rtx-rtos}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
El hilo en estado running. Además no es el único hilo porque aparece el hilo \sphinxcode{\sphinxupquote{osRtxIdleThread}} y \sphinxcode{\sphinxupquote{osRtxTimerThread}}.

\item {} 
\sphinxAtStartPar
Se visualiza una cola que es utiliza por el sistema operativo para gestionar eventos internos.

\end{enumerate}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Challenge: Investigue el mecanismo para poder poner su propio código en el thread \sphinxcode{\sphinxupquote{osRtxIdleThread}}.
\end{sphinxadmonition}

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
No utilice las funciones de manejo de timers software desde rutinas de atención a la interrupción.
\end{sphinxadmonition}



\renewcommand{\indexname}{Index}
\printindex
\end{document}