\section{Content}

\begin{frame}{Desarrollo de aplicaciones con Microprocesadores}
    \begin{itemize}
        \item Aplicaciones sencillas (fácil implementarlas mediante un bucle while, algunos timers y algunas interrupciones)
Si la complejidad de la aplicación crece, el número de temporizaciones aumenta frente al número de timers disponibles en el microprocesador y la lógica de la misma es compleja, la gestión, desarrollo y depuración de la aplicación se complican enormemente.
        \item Para simplificar esta situación se han desarrollado Sistemas Operativos “ligeros” para ser implementados en arquitecturas basadas en microprocesadores. Su utilización permite que el desarrollo de software sea más sencillo, seguro, y eficiente, redundando en un mantenimiento más sencillo del software.      
    \end{itemize}
     \centering

\end{frame}


\begin{frame}{CMSIS-RTOS}
    \begin{itemize}
      \item API C/C++ para sistemas operativos en tiempo real
      \item Diseñado para procesadores Cortex M
      \item Versión a utilizar CMSIS-RTOS2. Está se puede configurar para usar los kernels CMSIS-RTX (o keil RTX5), freeRTOS, Zephyr, embOS, Azure Thread y Micrium.
      \item En SBM usamos 2.1.3 que se basa en CMSIS v5 con RTX \href{https://arm-software.github.io/CMSIS_5/RTOS2/html/index.html}{Documentación 2.1.3}
      \item ARM ya ha lanzado la versión 2.3.0 que se basa en CMSIS V6 \href{https://arm-software.github.io/CMSIS_6/latest/RTOS2/group__CMSIS__RTOS__ThreadMgmt.html}{Documentación 2.3.0}
    \end{itemize}
    
\end{frame}

\begin{frame}{CMSIS-RTOS: Características}
    \begin{itemize}
  \item \textbf{Aplicaciones multihilo}: basada en la utilización de hilos concurrentes.
  \item Aporta mecanismos de comunicación y sincronización entre hilos.
  \item \textbf{Thread}:
    \begin{itemize}
        \item Porción de código que realiza una función concreta.
        \item Típicamente es una función con un bucle infinito y sin retorno.
        \item El RTOS permite compartir la ejecución con otros threads.
        \item 5 estados: \texttt{Running}, \texttt{Ready}, \texttt{Waiting/Blocked}, \texttt{Inactive}, \texttt{Terminated}.
    \end{itemize}
  \item \textbf{Scheduler}:
    \begin{itemize}
        \item Planificación y compartición de los recursos de CPU.
        \item Gestiona la ejecución de threads asignando tiempo (\texttt{SysTick}) de procesador a cada hilo.
    \end{itemize}
  \item \textbf{Timeslice}:
    \begin{itemize}
        \item Período de tiempo asignado a cada hilo.
        \item Múltiplo del Tick (5) generado por el \texttt{SysTick} (1ms).
    \end{itemize}
\end{itemize}

\end{frame}

\begin{frame}{CMSIS-RTOS: Planificador}
    \begin{itemize}
      \item \textbf{Pre-emptive}
          \begin{itemize}
            \item Desalojo de hilos “–prioritarios” por hilos “+prioritarios”.
          \end{itemize}
      \item \textbf{Round-Robin}
          \begin{itemize}
            \item Todos los hilos con la misma prioridad.
            \item Se ejecutan unos detrás de otros en secuencia durante un “timeslice”.
      \end{itemize}
      \item \textbf{Round-Robin Pre-emptive}
          \begin{itemize}
            \item Los hilos pueden tener distinta prioridad.
            \item Los hilos con igual prioridad se ejecutan de forma Round-Robin mientras no haya otro hilo de +prioridad en estado \texttt{READY}.
            \item Cuidado con las prioridades para no “colgar” la aplicación.
            \item Por defecto en CMSIS-RTOS - RTX.
      \end{itemize}
      \item \textbf{Cooperative Multitasking}
          \begin{itemize}
            \item Todos los hilos con igual prioridad.
            \item No Round-Robin.
            \item Cada hilo se ejecuta hasta bloquearse (pasa a \texttt{WAIT}) o hasta pasar la ejecución a otro (\texttt{yield}).
          \end{itemize}
    \end{itemize}
\end{frame}


\begin{frame}{CMSIS-RTOS: Estados en Threads}
    \begin{itemize}
        \item El planificador del SO es el encargado de gestionar la ejecución de un thread
        \item Estados de un thread:
       \begin{itemize}
          \item \textbf{RUNNING}: thread actualmente en ejecución.
          \item \textbf{READY}: threads preparados para ser ejecutados. Una vez que la tarea que se está ejecutando ha consumido su \textit{timeslice}, la siguiente tarea con máxima prioridad pasa a \textbf{RUNNING}.
          \item \textbf{BLOCKED/WAITING}: threads esperando la ocurrencia de algún evento.
          \item \textbf{TERMINATED}: threads terminados pero sin liberar recursos.
          \item \textbf{INACTIVE}: threads no creados o terminados. No consumen ningún recurso.
        \end{itemize}
    \end{itemize}
    
\end{frame}

\begin{frame}[fragile]{Thread in Keil Microvision}
    \begin{minted}[fontsize=\scriptsize, bgcolor=blue!5]{c}
    #include "cmsis_os2.h"
    
    osThreadId_t tid_thread; // tid_thread identifica al thread.Se usará en funciones específicas del RTOS
    ...
    
    tid_Thread = osThreadNew(Thread, NULL, NULL);
    if (tid_Thread == NULL) {
        return(-1);
    }


    void Thread (void *argument){
        // inserte el código que solo quiera que se ejecute una vez
        while(1){
        // inserte el código que quiera que se ejecute continuamente
        
        }
        // nunca se llega a este punto en este ejemplo
    
    }
    \end{minted}
    \begin{itemize}
        \item Es altamente aconsejable crear un fichero de cabecera donde se deberán declarar la función de inicio para poder ser utilizados por otros módulos del software

    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Thread in Keil Microvision}
    \begin{columns}
        \begin{column}{0.50\textwidth}
            \begin{minted}[fontsize=\scriptsize, bgcolor=blue!5]{c}
#include "cmsis_os2.h"
#include "ThDisplay.h"

osThreadId_t tid_ThDisplay; 
...

tid_ThDisplay = osThreadNew(ThDisplay, 
                NULL, NULL);
if (tid_ThDisplay == NULL) {
    return(-1);
}


void ThDisplay (void *argument){
    int ciclo=0;
    Init_display();
    while(1){
    .....
    
    }
   

}
            \end{minted}
        \end{column}
    \begin{column}{0.50\textwidth}
        \begin{minted}[fontsize=\scriptsize, bgcolor=blue!5]{c}
        // Fichero principal
        int main(void){
            int status=0;
            HAL_Init();
            SystemClock_Config();
            SystemCoreClockUpdate();
        #ifdef RTE_CMSIS_RTOS2
            oskernelInitilize();
            status|= Init_ThDisplay();
            osKernelStart();
        #endif
        }
        \end{minted}
        \begin{minted}[fontsize=\scriptsize, bgcolor=blue!5]{c}
        // Fichero de cabecera      
        #include "stm32f4xx_hal.h"
        
        #ifndef __THDISPLAY__H
        #define __THDISPLAY__H
            #define S_PINTA  0x0001U
            int Init_ThDisplay(void);
        #endif
        
        \end{minted}
    \end{column}
    \end{columns}
    \begin{itemize}
        \item Es altamente aconsejable crear un fichero de cabecera donde se deberán declarar la función de inicio para poder ser utilizados por otros módulos del software

    \end{itemize}
\end{frame}

% \begin{frame}{Internet of Things: Applications}
%     \begin{itemize}
%         \item Smart Greenhouse
%         \begin{itemize}
%             \item Plant Health Monitoring
%             \item Watering Control
%             \item Locate Plants in Greenhouses
%             \item Stock and Management
%         \end{itemize}
%         \begin{center}
%              \includegraphics[width=0.5\textwidth]{trainingmaterials/project2-iot/greenhose.png}
%         \end{center}
%         \item Smart Supermarket
%         \begin{itemize}
%             \item Automated identification and restocking
%             \item Automatic payment authorization
%         \end{itemize}
%         \item Monitoring elderly/convalescent patients at home
%         \item Traffic regulation
%         \item Power grid management
%     \end{itemize}
% \end{frame}

% \begin{frame}{Internet of Things: Technologies}
%   \begin{itemize}
%     \item \textbf{Top Edge/Gateway}
%     \begin{itemize}
%       \item Linux (67\%)
%       \begin{itemize}
%         \item Ubuntu (27\%)
%         \item Raspbian (28\%)
%         \item Debian (28\%)
%       \end{itemize}
%       \item Windows (26\%)
%       \item Android (22\%)
%     \end{itemize}
%     \item \textbf{Constrained Devices}
%     \begin{itemize}
%       \item Linux (45\%)
%       \item FreeRTOS (29\%)
%       \item Bare Metal (21\%)
%       \item Zephyr (21\%)
%       \item Eclipse Threadx (13\%)
%     \end{itemize}
%     \item \textbf{Constrained Devices}
%     \begin{itemize}
%       \item 68\% ARM
%       \item 28\% ESP32
%       \item 13\% RISC-V
%     \end{itemize}
%   \end{itemize}

% \end{frame}

% \begin{frame}{Internet of Things: Technologies}
%     \begin{itemize}
%         \item Programming Languages 
%         \begin{itemize}
%             \item Constrained Devices: C (55\%), C++(36\%), Java (29\%), Python(32\%)
%             \item Gateways/Edge: Java (32\%), Python(39\%), Javascript (15\%), C++ (29\%)
%         \end{itemize}
%         \item Connectivity: Cellular (59\%), Ethernet (45\%), WiFi(46\%), Bluetooth (31\%)
%         \item Cloud Platforms: AWS(45\%), Azure(22\%), Google Cloud Platform (19\%)
%     \end{itemize}
%     \footnote{Source: Eclipse IOT Survey 2024 Percentage over complete system of applications under survey. Applications may include more than one technology in the system}
% \end{frame}

% \section{UDP/IP}
% \begin{frame}{UDP/IP}
%     \begin{columns}
%         \begin{column}{0.5\textwidth}
%             \begin{itemize}
%                 \item System connected on Local Area Network (LAN)
%                 \item Members: 
%                 \begin{itemize}
%                     \item RPI (Use UDP in Linux)
%                     \item Wifi Router
%                     \item Host Machine with Virtualized Ubuntu (Use UDP in Linux)
%                 \end{itemize}
%             \end{itemize}
%         \end{column}
%         \begin{column}{0.5\textwidth}
%             \centering
%             \includegraphics[]{trainingmaterials/project2-iot/ip.jpg}
%         \end{column}
%     \end{columns}
% \end{frame}

% \begin{frame}[fragile]{Server UDP/IP  C/C++} % important using minted you need fragile
%     \begin{columns}
%         \begin{column}{0.35\textwidth}
%             \begin{itemize}
%                 \item UDP Server operation
%                     \begin{itemize}
%                         \item Create UDP Socket
%                         \item Bind Socket to server address (Server IP address)
%                         \item Send and receive messages
%                         \item Close Socket
%                     \end{itemize}
%             \end{itemize}  
%         \end{column}
%         \begin{column}{0.65\textwidth}
%             \begin{minted}[fontsize=\scriptsize, bgcolor=blue!5]{c}
%     int sockfd = socket(int domain, int type, 
%         int protocol);
    
%     bind(int sockfd, const struct sockaddr *addr, 
%             socklen_t addrlen);
    
%     sendto(int sockfd, const void *buf, 
%             size_t len, 
%             int flags, 
%             const struct sockaddr *dest_addr, 
%             socklen_t addrlen);
    
%     revfrom(int sockfd, const void *buf, 
%             size_t len, 
%             int flags, 
%             const struct sockaddr *dest_addr, 
%             socklen_t addrlen);

%     close(int sockfd);
    
%              \end{minted}      
%         \end{column}   
%     \end{columns}
% \end{frame}

% \begin{frame}[fragile]{Client UDP/IP  C/C++} % important using minted you need fragile
%     \begin{columns}
%         \begin{column}{0.35\textwidth}
%             \begin{itemize}
%                 \item UDP Client operation
%                     \begin{itemize}
%                         \item Create UDP Socket
%                         \item Send and receive messages
%                         \item Close Socket
%                     \end{itemize}
%             \end{itemize}  
%         \end{column}
%         \begin{column}{0.65\textwidth}
%             \begin{minted}[fontsize=\scriptsize, bgcolor=blue!5]{c}
%     int sockfd = socket(int domain, int type, 
%         int protocol);

    
%     sendto(int sockfd, const void *buf, 
%             size_t len, 
%             int flags, 
%             const struct sockaddr *dest_addr, 
%             socklen_t addrlen);
    
%     revfrom(int sockfd, const void *buf, 
%             size_t len, 
%             int flags, 
%             const struct sockaddr *dest_addr, 
%             socklen_t addrlen);

%     close(int sockfd);
    
%              \end{minted}      
%         \end{column}   
%     \end{columns}
% \end{frame}

% \begin{frame}{UDP Client/Server}
% \centering
%     \includegraphics[width=0.65\textwidth]{trainingmaterials/project2-iot/udp-protocol.jpeg}
% \end{frame}

% \section{Project III: UDP Communication RPI/Ubuntu}
% \begin{frame}{System Minimal Requirements (Phase I: Mandatory)}
%     \begin{itemize}
%         \item Maximun grade 8.5 in 10
%             \begin{itemize}
%                 \item Hard-coding parameters is not allowed
%                 \item Pay attention to code clarity
%             \end{itemize}
%         \item Buildroot Linux Project II
%         \item UDP Client implemented in RPI
%         \item RPI samples data at 1 Sample/s
%         \item RPI sends data to server every 10s
%         \item Server calculates Mean/Max/Min/Std each minute
%         \item Information displayed in server terminal
%          \item Sensors: Accelerometer MPU6050 and TCS34725 (RGB)
%     \end{itemize}
% \end{frame}

% \begin{frame}[fragile]{System Minimal Requirements (Phase II: Optional)}
%     \begin{itemize} 
%         \item 1.5 additional mark 
%         \item Remote communications: MQTT Client in RPI (mosquitto client). Use Buildroot software packages
%         \item Information display: Thingsboard (dashboard)
%             \begin{itemize}
%                 \item \href {https://thingsboard.io/docs/user-guide/install/ubuntu/}{Thingsboard installation }
%                 \item You can use the mosquito client installed with Buildroot
%                 \begin{minted}{bash}
% mosquitto_pub -d -q 1 -h “hostip" -p "1883" -t "v1/devices/me/telemetry" -u “xxxxx" -m {“your variable":25}
%                 \end{minted}
%                 \item \href{https://thingsboard.io/docs/getting-started-guides/helloworld/?connectdevice=mqtt-linux}{MQTT ...more details}

%             \end{itemize}
%     \end{itemize}
% \end{frame}

% \section{Project III Deliverables}
% \begin{frame}{Deliverables}
%     \begin{itemize}
%         \item Source code (Phase I): Both Client/Server side (Commented)
%         \item Optional part (in case you complete it)
%         \item Due date: 19/05/2025 (8:30)
%         \item PowerPoint presentation 
%         \item Oral presentation + Demo Class on 19/05/2025 at 12:30
%     \end{itemize}
% \end{frame}